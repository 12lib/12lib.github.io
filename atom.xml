<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>librarian</title>
  
  
  <link href="http://librariany.cn/atom.xml" rel="self"/>
  
  <link href="http://librariany.cn/"/>
  <updated>2023-08-05T02:11:34.708Z</updated>
  <id>http://librariany.cn/</id>
  
  <author>
    <name>y</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>xdbg食品检测记录之一</title>
    <link href="http://librariany.cn/2023/08/04/xdbg/"/>
    <id>http://librariany.cn/2023/08/04/xdbg/</id>
    <published>2023-08-04T09:49:12.000Z</published>
    <updated>2023-08-05T02:11:34.708Z</updated>
    
    <content type="html"><![CDATA[<p>关于跟着教程自学逆向这件事（1）</p><span id="more"></span><h2 id="xdbg"><a href="#xdbg" class="headerlink" title="xdbg"></a>xdbg</h2><p>xdbg有64位和32位两个版本，用来逆向不同位的程序，在编译器里面选择x64配置就是64位，我后续的代码是x86所以用的是x32dbg。<br>先给个我自己语言描述的个窗口功能图吧,具体作用后续展示图来体会。<br><img src="/2023/08/04/xdbg/0.0.png"><br>再给个后续经常用到的转到（go to）功能介绍，在编写程序时一些函数库里面的函数（比如printf，messagebox）可以直接被识别，帮助我们在0和1之间找到主函数所在。<br><img src="/2023/08/04/xdbg/1.1.png"><br>搜索messageboxw（一般messagebox默认的是w，可以在编写的时候写messageboxa并搜索messageboxa），找到后在命令处打断点并执行到断点处，然后在右下角的堆栈区找到从哪里转到这里来的，然后回车到原来的地方去，那里就是调用这个函数的地方。<br><img src="/2023/08/04/xdbg/1.2.png"></p><h2 id="c-嵌入汇编代码"><a href="#c-嵌入汇编代码" class="headerlink" title="c++嵌入汇编代码"></a>c++嵌入汇编代码</h2><p>之所以我的代码都是32位正是因为64位的编译器不允许我嵌入汇编。<br>代码如下。<br><img src="/2023/08/04/xdbg/1.0.png"><br>在汇编中找到主函数,这里是通过messageboxa的搜索转到的主函数，因为需要看见主函数的执行所以不是直接挑战看代码，而是让程序一步步执行到messageboxa调用的下一步来，从而回到主函数。我在代码里面为其赋值赋了两次，一次汇编一次c++，而在那个mov指令的框里逆向出来的代码和汇编代码没有差别。<br><img src="/2023/08/04/xdbg/1.3.png"><br>上图右边的框里面有汇编代码对应的源程序的位置，这来自于存储了调试信息的pbd文件，删除后就没有了。另外在发布软件时都不会发布debug版本以及pbd文件，所以在生成执行文件时我均采用的release。<br><img src="/2023/08/04/xdbg/1.4.png"><br>删除后<br><img src="/2023/08/04/xdbg/1.5.png"></p><h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><p>代码如下<br><img src="/2023/08/04/xdbg/2.0.png"><br>同样根据messagebox找到主函数所在,并找到add所在。<br>执行的指令所在就是主函数，在压入数值之后的执行指令就是转向了add函数，根据地址（8B1000）或者步进执行过call指令跳转到add函数。add函数也就是编译器执行加法的汇编语言流程，在add函数的末尾可以看见ret指令用于返回主函数。<br><img src="/2023/08/04/xdbg/2.3.png"><br>而这个结果是在关闭了编译器自带的代码优化得到的，因为这里的加法可以直接由CPU算出来，调用函数反而会减慢速度。<br>下图是关闭的方法和未关闭的效果。<br><img src="/2023/08/04/xdbg/2.2.png"><br><img src="/2023/08/04/xdbg/2.1.png"></p><h2 id="寄存器收纳的数据位数"><a href="#寄存器收纳的数据位数" class="headerlink" title="寄存器收纳的数据位数"></a>寄存器收纳的数据位数</h2><p>在写代码时的int short char long代表了数据的长度，分配了内存的长度，接下来用代码来验证一下。<br><img src="/2023/08/04/xdbg/3.0.png"><br>eax是32位CPU的寄存器（至少不是一字节大小的），可以储存16进制的222.在第一段汇编代码中的add，没有规定字节大小的默认为一字节所以在逆向汇编时只看得见存储成功的11，word是两字节2211，dword四字节所以44332211.这同样也是前面的代码<br>同样的在第二段汇编代码中，因为赋值的变量在之前用int等定义了所占内存大小，所以成功存储的大小仍然不超过该大小。<br><img src="/2023/08/04/xdbg/3.3.png"><br>顺便也看一下第一段汇编代码里面对寄存器内部数据的改变，也就是存储222的eax和存储地址的ebx。<br><img src="/2023/08/04/xdbg/3.1.png"><br><img src="/2023/08/04/xdbg/3.2.png"></p><p>自学的视频来源是<a href="https://www.bilibili.com/video/BV1Jb411p7fU/">https://www.bilibili.com/video/BV1Jb411p7fU/</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;关于跟着教程自学逆向这件事（1）&lt;/p&gt;</summary>
    
    
    
    
    <category term="逆向" scheme="http://librariany.cn/tags/%E9%80%86%E5%90%91/"/>
    
    <category term="工具" scheme="http://librariany.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>final shell连接超时</title>
    <link href="http://librariany.cn/2023/07/31/final-shell%E8%BF%9E%E6%8E%A5%E8%B6%85%E6%97%B6/"/>
    <id>http://librariany.cn/2023/07/31/final-shell%E8%BF%9E%E6%8E%A5%E8%B6%85%E6%97%B6/</id>
    <published>2023-07-31T04:01:24.000Z</published>
    <updated>2023-07-31T04:10:14.576Z</updated>
    
    <content type="html"><![CDATA[<p>关于我弄了一个傍晚加一个上午的连接这件事</p><span id="more"></span><p>没截图（出问题的时候没想着截图，有缘再，算了这种缘分无福消受），写个大概，问题发生的背景是我的vmware卸载过。<br>在final shell连接的时候显示连接超时，找了教程去修改了虚拟网络编辑器，在更改wmnet8的时候修改了很多次，每次配置更改的小窗显示特别久但是一直没能成功把主机虚拟适配器那个勾选上。<br><img src="/2023/07/31/final-shell%E8%BF%9E%E6%8E%A5%E8%B6%85%E6%97%B6/net.png"><br>后来去搜了一下是因为上一次卸载没卸载干净，所以去下载了ccleaner。把上一次的注册表删完了，顺手还删了一些其他的被检测出来的注册表，我选择了先备个份怕删错。（这个我是直接网上搜的ccleaner官网下的试用装）<br><img src="/2023/07/31/final-shell%E8%BF%9E%E6%8E%A5%E8%B6%85%E6%97%B6/ccleaner.png"><br>到这里大概就可以尝试去虚拟机 ifconfig 找ip了（后续就是我的冤种路线，如果不行可以尝试在网络配置那里恢复默认设置，说不定是之前的影响）。<br>当时我直接冲进来把vmnet8给改了，惯性了属于是。<br>导致我的虚拟机在更改后显示 activation of network connection failed。<br>尝试去打开&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;，然后vim进入ifcfg-ens33，显示这个文件名错误，整个编辑界面是空白的，出问题哩。<br>折腾很久想起来去把网络编辑器还原了默认配置，然后重新config发现正常了，就按照连接final shell的方法，重新连接了一下成功了。<br><img src="/2023/07/31/final-shell%E8%BF%9E%E6%8E%A5%E8%B6%85%E6%97%B6/config.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;关于我弄了一个傍晚加一个上午的连接这件事&lt;/p&gt;</summary>
    
    
    
    
    <category term="linux" scheme="http://librariany.cn/tags/linux/"/>
    
    <category term="倒霉日记" scheme="http://librariany.cn/tags/%E5%80%92%E9%9C%89%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言13-15自学回顾</title>
    <link href="http://librariany.cn/2023/07/25/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%8013-15/"/>
    <id>http://librariany.cn/2023/07/25/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%8013-15/</id>
    <published>2023-07-25T11:27:56.000Z</published>
    <updated>2023-08-07T10:37:01.890Z</updated>
    
    <content type="html"><![CDATA[<p>基本上都直接通过实验的代码分析来回顾。</p><span id="more"></span><h2 id="第13章"><a href="#第13章" class="headerlink" title="第13章"></a>第13章</h2><h3 id="int指令"><a href="#int指令" class="headerlink" title="int指令"></a>int指令</h3><p>int指令也属于内中断的一种，格式为 <code>int n</code> ，其中n为中断类型码，跟前面的中断执行过程差不多，不过直接给出了中断类型码，可以任意指定进行的中断处理程序。执行过程：获取中断类型码n-&gt;标志寄存器入栈，IF&#x3D;0，TF&#x3D;0-&gt;CS,IP入栈-&gt;(IP)&#x3D;(n<em>4),(CS)&#x3D;(n</em>4+2)-&gt;执行处理程序。</p><h3 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h3><p>在系统板上的BIOS（基本输入输出系统）主要提供：硬件系统的检测和初始化程序；外部中断和内部中断的中断例程；用于对硬件设备进行I&#x2F;O操作的中断例程；其他和硬件系统相关的中断例程。操作系统DOS也提供中断例程。<br>BIOS和DOS的中断例程包含了许多子程序，这些子程序实现了程序员在编程的时候常常需要用到的功能。程序员在编程的时候可以直接用int调用其中的中断例程。<br>BIOS和DOS的安装过程为：开机后CPU加电，初始化（CS）&#x3D;0FFFFH，（IP）&#x3D;0，在FFFF：0处有一条跳转指令，执行后进行BIOS的硬件系统检测和初始化程序 -&gt; 初始化程序建立BIOS的中断向量并将入口地址登记在中断向量表 -&gt; 系统硬件检测和初始化完成后调用 int 91h，进行操作系统的应道，计算机交由操作系统 -&gt; DOS启动后还会将其提供的中断例程装入内存，建立中断向量。</p><h3 id="实验13"><a href="#实验13" class="headerlink" title="实验13"></a>实验13</h3><p>1.编写并安装 int 7ch 中断例程，功能为显示一个用0结束的字符串，中断例程安装在0：200处。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">    mov ax,cs               ;将程序复制到0：200h处</span><br><span class="line">mov ds,ax   </span><br><span class="line">mov si,offset new</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,200h</span><br><span class="line">mov cx,offset newend-offset new</span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br><span class="line"></span><br><span class="line">mov ax,0                ;中断向量表</span><br><span class="line">mov es,ax</span><br><span class="line">mov word ptr es:[7ch*4],200h</span><br><span class="line">mov word ptr es:[7ch*4+2],0</span><br><span class="line">    </span><br><span class="line">    mov ax,4c00H</span><br><span class="line">    int 21H</span><br><span class="line"></span><br><span class="line">new:</span><br><span class="line">push ax                 ;中断程序也需要压栈</span><br><span class="line">push bx</span><br><span class="line">push cx</span><br><span class="line">push ds</span><br><span class="line">push es</span><br><span class="line">push si</span><br><span class="line">push di</span><br><span class="line"></span><br><span class="line">mov ax,0b800h           ;显示缓存区</span><br><span class="line">mov es,ax</span><br><span class="line"></span><br><span class="line">mov ax,160              ;dh为行号，160为书上一行的长度，我自己的我没算过</span><br><span class="line">mul dh</span><br><span class="line">mov di,ax</span><br><span class="line"></span><br><span class="line">mov ax,2                ;dl为列好，乘法算显示位置</span><br><span class="line">mul dl</span><br><span class="line">add di,ax</span><br><span class="line"></span><br><span class="line">mov bl,cl               ;cl为颜色</span><br><span class="line"></span><br><span class="line">s:</span><br><span class="line">mov cl,ds:[si]          ;颜色暂存在bl，这里来判断是否为末尾的0</span><br><span class="line">mov ch,0</span><br><span class="line">jcxz ok</span><br><span class="line"></span><br><span class="line">mov es:[di],cl          ;低位数据</span><br><span class="line">mov es:[di+1],bl;高位款式</span><br><span class="line">add di,2</span><br><span class="line"></span><br><span class="line">inc si</span><br><span class="line"></span><br><span class="line">jmp short s</span><br><span class="line"></span><br><span class="line">ok:</span><br><span class="line">pop di                  ;回复原样</span><br><span class="line">pop si</span><br><span class="line">pop es</span><br><span class="line">pop ds</span><br><span class="line">pop cx</span><br><span class="line">pop bx</span><br><span class="line">pop ax</span><br><span class="line"></span><br><span class="line">iret</span><br><span class="line"></span><br><span class="line">newend:nop                  ;方便定位程序的长度，nop没啥实际意义</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>给了个测试程序吧相当于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">db &quot;welcome to masm!&quot;,0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov dh,10</span><br><span class="line">mov dl,10</span><br><span class="line">mov cl,2</span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,0</span><br><span class="line">int 7ch</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>调试结果如下<br><img src="/2023/07/25/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%8013-15/13.1.png"><br>在开始时sp为0000，int 7c后sp被设置并且入栈标志寄存器和CS，IP，并且跳转指令<br><img src="/2023/07/25/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%8013-15/13.2.png"><br>中断例程执行完后栈恢复<br><img src="/2023/07/25/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%8013-15/13.3.png"></p><p>2.编写并安装 int 7ch 中断例程，功能为完成loop指令的功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"> start:</span><br><span class="line">    mov ax,cs               ;将程序放到0：200h</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,offset relo</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,200h</span><br><span class="line">mov cx,offset reloend-offset relo</span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br><span class="line"></span><br><span class="line">mov ax,0                ;中断向量表</span><br><span class="line">mov es,ax</span><br><span class="line">mov word ptr es:[7ch*4],200h</span><br><span class="line">mov word ptr es:[7ch*4+2],0</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line"> relo:</span><br><span class="line">    push bp                 ;将bp原有内容备份</span><br><span class="line">mov bp,sp               ;将现有偏移地址放到bp中</span><br><span class="line">dec cx</span><br><span class="line">jcxz lpret              </span><br><span class="line">add [bp+2],bx           ;bx是在另一个程序中给出来的该程序的调用到需要循环的程序的偏移地址，bp+2就是sp所在地，相加后再次执行时sp就在需要循环的指令处了</span><br><span class="line"></span><br><span class="line"> lpret:</span><br><span class="line">    pop bp                  </span><br><span class="line">iret                    ;如果在循环中返回修改过的cs：ip，80够了就直接往下</span><br><span class="line"> reloend:nop</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>给出的调试的程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"> start:mov ax,0b800h</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,160*12</span><br><span class="line">mov bx,offset s-offset se</span><br><span class="line">mov cx,80</span><br><span class="line"></span><br><span class="line"> s:mov byte ptr es:[di],&#x27;!&#x27;    ;重复80个！</span><br><span class="line">add di,2</span><br><span class="line">int 7ch</span><br><span class="line"></span><br><span class="line"> se:nop</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>效果图<br><img src="/2023/07/25/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%8013-15/13.4.png"></p><p>3.下面的程序，在屏幕的第2，4，6，8行显示4句英文诗</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">s1:db &#x27;Good,better,best,&#x27;,&#x27;$&#x27;</span><br><span class="line">s2: db &#x27;Never let it rest&#x27;,&#x27;$&#x27;</span><br><span class="line">s3: db &#x27;Till good is better&#x27;,&#x27;$&#x27;</span><br><span class="line">s4: db &#x27;And better,best.&#x27;,&#x27;$&#x27;</span><br><span class="line">s : dw offset s1,offset s2,offset s3,offset s4</span><br><span class="line">row: db 2,4,6,8</span><br><span class="line"></span><br><span class="line">strat:</span><br><span class="line">mov ax,cs               ;找到数据的段地址</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,offset s         ;找到每句话的偏移地址</span><br><span class="line">mov si,offset row       ;存储的显示行</span><br><span class="line">mov cx,4</span><br><span class="line">ok:</span><br><span class="line">mov bh,0                ;行号</span><br><span class="line">mov dh,[si]</span><br><span class="line">mov dl,0                ;列号</span><br><span class="line">mov ah,2                ;在int 10h中ah，9为放置光标</span><br><span class="line">int 10h</span><br><span class="line"></span><br><span class="line">mov dx,[bx]             ;ds:dx指向字符串</span><br><span class="line">mov ah,9                ;int 21h中在光标处显示字符</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">inc si                  ;指向下一个字符串</span><br><span class="line">add bx,2</span><br><span class="line">loop ok</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end strat</span><br></pre></td></tr></table></figure><p>效果图<br><img src="/2023/07/25/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%8013-15/13.5.png"></p><h2 id="第14章"><a href="#第14章" class="headerlink" title="第14章"></a>第14章</h2><h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>在pc机上各种接卡口，主板上的接口芯片，其他芯片等都与CPU总线相连，CPU通过控制线向他们所在芯片发出端口读写指令。在CPU角度，将这些寄存器都当作端口，对他们进行统一编址，从而建立统一的端口地址空间。<br>端口的读写指令只有两条：in，out分别为从端口读取和向端口写入。在读取和写入时只能用ax或者al来存放数据，8位端口用al，16位用ax。</p><h3 id="shr-amp-shl"><a href="#shr-amp-shl" class="headerlink" title="shr &amp; shl"></a>shr &amp; shl</h3><p>shr和shl为逻辑移位符，shr为右移，shl左移。<code>shl 1</code>为例：将一个寄存器或者内存单元中的数据左移一位-&gt;将最后移出的一位写入CF中-&gt; 缺失位补0。</p><h3 id="实验14"><a href="#实验14" class="headerlink" title="实验14"></a>实验14</h3><p>以“年&#x2F;月&#x2F;日 时:分:秒”的格式，显示当前日期时间。在CMOS RAM中实时钟存储时间的单元为秒0分2时4日7月8年9。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">db &quot;/&quot;,&#x27; &#x27;,&#x27;:&#x27;      ;需要用到的符号</span><br><span class="line">db 9,8,7,4,2,0      ;因为储存顺序原因，直接按顺序存储单元位置</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"> start:mov ax,data     ;找到数据存储位置</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,3            ;单元的位移</span><br><span class="line">mov bx,0b800h       ;显示缓存区</span><br><span class="line">mov es,bx</span><br><span class="line">mov di,0            ;符号的位移</span><br><span class="line">mov cx,3</span><br><span class="line"></span><br><span class="line"> s:push cx             ;先存储cx内容后续需要使用cl</span><br><span class="line">mov al,ds:[si]      ;在CMOS中读取</span><br><span class="line">out 70h,al</span><br><span class="line">in al,71h</span><br><span class="line"></span><br><span class="line">mov ah,al           ;处理读出的8位的数据，8位分成4位存储了两个数据，高位为十位</span><br><span class="line">mov cl,4</span><br><span class="line">shr ah,cl</span><br><span class="line">and al,00001111b</span><br><span class="line"></span><br><span class="line">add ah,30h          ;数字变成ASCII码表的对应</span><br><span class="line">add al,30h</span><br><span class="line"></span><br><span class="line">mov byte ptr es:[160*12+40*2+di],ah     ;分别显示高低位的数据</span><br><span class="line">mov byte ptr es:[160*12+40*2+2+di],al</span><br><span class="line"></span><br><span class="line">mov al,ds:[0]                           ;显示符号</span><br><span class="line">mov byte ptr es:[160*12+40*2+4+di],al</span><br><span class="line"></span><br><span class="line">inc si</span><br><span class="line">add di,6</span><br><span class="line">pop cx</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov al,ds:[1]                           ;将上一个/替换为空格</span><br><span class="line">mov byte ptr es:[160*12+40*2+16],al</span><br><span class="line">add di,2</span><br><span class="line"></span><br><span class="line">mov cx,3                                ;操作流程同上</span><br><span class="line"></span><br><span class="line"> s1:push cx</span><br><span class="line">mov al,ds:[si]</span><br><span class="line">out 70h,al</span><br><span class="line">in al,71h</span><br><span class="line"></span><br><span class="line">mov ah,al</span><br><span class="line">mov cl,4</span><br><span class="line">shr ah,cl</span><br><span class="line">and al,00001111b</span><br><span class="line"></span><br><span class="line">add ah,30h</span><br><span class="line">add al,30h</span><br><span class="line"></span><br><span class="line">mov byte ptr es:[160*12+40*2+di],ah</span><br><span class="line">mov byte ptr es:[160*12+40*2+2+di],al</span><br><span class="line"></span><br><span class="line">mov al,ds:[2]</span><br><span class="line">mov byte ptr es:[160*12+40*2+4+di],al</span><br><span class="line"></span><br><span class="line">inc si</span><br><span class="line">add di,6</span><br><span class="line">pop cx</span><br><span class="line">loop s1</span><br><span class="line"></span><br><span class="line">mov al,ds:[1]</span><br><span class="line">mov byte ptr es:[160*12+40*2+36],al</span><br><span class="line">add di,2</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>效果图<br><img src="/2023/07/25/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%8013-15/14.1.png"><br>看一个我忘了push cx导致的错误示范图,蛮好玩的<br><img src="/2023/07/25/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%8013-15/14.0.png"></p><h2 id="第15章"><a href="#第15章" class="headerlink" title="第15章"></a>第15章</h2><h3 id="外中断"><a href="#外中断" class="headerlink" title="外中断"></a>外中断</h3><p>CPU的外部有需要处理的事情发生时会产生外中断的中断信息，外中断源有两种：可屏蔽中断，不可屏蔽中断。<br>可屏蔽中断的判断为IF&#x3D;1，则在执行完该指令后中断。在中断过程中将IF置0就是为了防止其他可屏蔽中断。而sti指令可以将IF&#x3D;1；cli指令可以将IF&#x3D;0.</p><h3 id="PC机的键盘输入"><a href="#PC机的键盘输入" class="headerlink" title="PC机的键盘输入"></a>PC机的键盘输入</h3><p>键盘的每个键相当于一个开关，按下和松开产生扫描码，按下称为通码，松开称为断码。断码&#x3D;通码+80h。扫描码会被送往60h端口，键盘的输入到达60h后相关芯片会往CPU发出中断类型码为9的可屏蔽中断信息。</p><h3 id="实验15"><a href="#实验15" class="headerlink" title="实验15"></a>实验15</h3><p>安装一个 int 9h ，效果为按下‘A’后再松开就会出现满屏‘A’。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">db 128 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"> start:mov ax,stack</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,128</span><br><span class="line"></span><br><span class="line">push cs</span><br><span class="line">pop ds</span><br><span class="line"></span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line"></span><br><span class="line">mov si,offset int9          ;安装int 9h程序</span><br><span class="line">mov di,204h</span><br><span class="line">mov cx,offset int9end - offset int9</span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br><span class="line"></span><br><span class="line">push es:[9*4]               ;通过栈存储原int 9h的内容，方便后续调用</span><br><span class="line">pop es:[200h]</span><br><span class="line">push es:[9*4+2]</span><br><span class="line">pop es:[202h]</span><br><span class="line"></span><br><span class="line">cli </span><br><span class="line">mov word ptr es:[9*4],204h      ;中断向量表</span><br><span class="line">mov word ptr es:[9*4+2],0h</span><br><span class="line">sti</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line"> int9:</span><br><span class="line">    push ax                         ;备份</span><br><span class="line">push bx</span><br><span class="line">push cx</span><br><span class="line">push es</span><br><span class="line"></span><br><span class="line">in al,60h                       ;指定60h端口</span><br><span class="line"></span><br><span class="line">pushf                           ;简化后成果具体看末尾</span><br><span class="line">call dword ptr cs:[200h]</span><br><span class="line"></span><br><span class="line">cmp al,9eh                      ;检测断码</span><br><span class="line">jne int9ret</span><br><span class="line"></span><br><span class="line">mov ax,0b800h                   ;输出满屏A</span><br><span class="line">mov es,ax</span><br><span class="line">mov bx,0</span><br><span class="line">mov ah,41h</span><br><span class="line">mov cx,2000</span><br><span class="line"></span><br><span class="line"> s:mov es:[bx],ah</span><br><span class="line">add bx,2</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line"> int9ret:</span><br><span class="line">pop es                          ;回档原来的寄存器</span><br><span class="line">pop cx</span><br><span class="line">pop bx</span><br><span class="line">pop ax</span><br><span class="line">iret</span><br><span class="line"></span><br><span class="line"> int9end:nop</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>关于简化的部分是在模拟原来的int指令的调用过程，因为此处调用的原int 9h已经不是int指令了。即取中断类型码-&gt;标志寄存器入栈-&gt;IF,TF置零-&gt;CS,IP入栈-&gt;跳转指令。<br>最后两步和call指令效果类似，标志寄存器入栈可以用pushf，对于置零可以由一下指令完成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pushf</span><br><span class="line">pop ax</span><br><span class="line">and ah,11111100b</span><br><span class="line">push ax</span><br><span class="line">popf</span><br></pre></td></tr></table></figure><p>由于在上面的程序中已经在进入中断程序时将IF，TF置零了，不需要这一堆只用pushf和call。<br>效果图如下,图一为按住A不放，图二为放开后<br><img src="/2023/07/25/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%8013-15/15.1.png"><br><img src="/2023/07/25/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%8013-15/15.2.png"><br>说真的边敲代码边开着饭拍的凤凰传奇音乐节live非常提神醒脑，美中不足是没办法控制抖腿。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;基本上都直接通过实验的代码分析来回顾。&lt;/p&gt;</summary>
    
    
    
    <category term="《汇编语言》自学之路" scheme="http://librariany.cn/categories/%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="汇编" scheme="http://librariany.cn/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言10-12自学回顾</title>
    <link href="http://librariany.cn/2023/07/20/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%8010-12/"/>
    <id>http://librariany.cn/2023/07/20/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%8010-12/</id>
    <published>2023-07-20T02:48:40.000Z</published>
    <updated>2023-08-07T10:34:14.282Z</updated>
    
    <content type="html"><![CDATA[<p>摸鱼的进度确实不太行呢</p><span id="more"></span><h2 id="第10章"><a href="#第10章" class="headerlink" title="第10章"></a>第10章</h2><h3 id="ret-amp-retf-amp-call"><a href="#ret-amp-retf-amp-call" class="headerlink" title="ret &amp; retf &amp; call"></a>ret &amp; retf &amp; call</h3><p>ret指令可以用栈中的数据修改IP内容，retf则可以用栈中数据修改CS和IP从而实现转移。操作也就相当于令ip和cs等于栈顶元素然后再将栈顶元素出栈。<br>call指令也是跳转指令，先将ip或者cs和ip压入栈（先cs后ip）再转移到指定的偏移地址。而这个偏移位移&#x3D;标号处的地址减去call后第一个指令的地址。也就是先把call指令放入缓存区将当前ip移到下一条指令后执行转移。<br>格式有：call 16位寄存器 入栈ip；call far ptr 标号 入栈cs,ip段间转移；call word ptr 内存单元地址 入栈ip；call dword ptr 内存单元地址 入栈cs，ip。<br>可以通过call一个标识，在标识内写入函数，并在最后通过ret返回的方式以栈作为中转来实现函数调用。</p><h3 id="mul"><a href="#mul" class="headerlink" title="mul"></a>mul</h3><p>mul是乘法指令，格式为：mul reg ，两个相乘的需要是两哥位数相同的寄存器，如果是8位默认将给出的寄存器与al相乘，16位则是和ax相乘。8位的结果保存在ax中，16位低位在ax高位在dx。</p><h3 id="实验10"><a href="#实验10" class="headerlink" title="实验10"></a>实验10</h3><p>1.显示字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">data segment</span><br><span class="line">db &#x27;Welcome to masm!&#x27;,0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:  mov dh,15   ;8行太靠前了</span><br><span class="line">mov dl,25       ;3列也是</span><br><span class="line">mov cl,2        ;决定字的样式</span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,0</span><br><span class="line">call show_str</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">show_str:       </span><br><span class="line">push ax        ;在子函数中调用寄存器的时候为了避免寄存器冲突，全部入栈一遍</span><br><span class="line">push bx</span><br><span class="line">push cx</span><br><span class="line">push dx</span><br><span class="line">push es</span><br><span class="line">push si</span><br><span class="line">push di</span><br><span class="line"></span><br><span class="line">mov ax,0b800h</span><br><span class="line">mov es,ax</span><br><span class="line"></span><br><span class="line">mov al,160</span><br><span class="line">mul dh</span><br><span class="line">mov bx,ax</span><br><span class="line">mov al,2</span><br><span class="line">mul dl</span><br><span class="line">add bx,ax</span><br><span class="line"></span><br><span class="line">mov al,cl</span><br><span class="line">mov ch,0</span><br><span class="line">mov di,0</span><br><span class="line"></span><br><span class="line">showc:  mov cl,ds:[si]</span><br><span class="line">jcxz ok</span><br><span class="line">mov es:[bx+di],cl</span><br><span class="line">mov es:[bx+di+1],al</span><br><span class="line">inc si</span><br><span class="line">add di,2</span><br><span class="line">jmp short showc</span><br><span class="line"></span><br><span class="line">ok:     pop di</span><br><span class="line">pop si</span><br><span class="line">pop es</span><br><span class="line">pop dx</span><br><span class="line">pop cx</span><br><span class="line">pop bx</span><br><span class="line">pop ax</span><br><span class="line">ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>效果如下<br><img src="/2023/07/20/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%8010-12/10.1.png"><br>2.解决除法溢出，将除法分解为高低位分别计算: x&#x2F;n&#x3D;int(高位&#x2F;n)<em>65536+(rem(高位&#x2F;n</em>65536)+低位)&#x2F;n</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:  mov ax,4240h</span><br><span class="line">mov dx,00fh</span><br><span class="line">mov cx,0ah</span><br><span class="line">call divdw</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">divdw:  mov bx,ax</span><br><span class="line">mov ax,dx</span><br><span class="line">mov dx,0</span><br><span class="line">div cx      ;高位部分的除法，商本来就在高位存放，余数在低位继续除法</span><br><span class="line">mov si,ax   ;ax存储商dx存储余数</span><br><span class="line"></span><br><span class="line">mov ax,bx   ;重新把低位给放回ax和上一次除法储存在dx的余数作为高位完成除法</span><br><span class="line">div cx</span><br><span class="line"></span><br><span class="line">mov cx,dx   ;cx存放余数，dx高位，ax低位</span><br><span class="line">mov dx,si</span><br><span class="line"></span><br><span class="line">ret</span><br><span class="line">codesg ends  </span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>效果如下<br><img src="/2023/07/20/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%8010-12/10.2.png"><br>3.数值显示，把数据段的数据以十进制显示出来，通过除法转化为十进制，再对照ASCII码表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">db 10 dup (0)</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:  </span><br><span class="line">    mov ax,12666    ;作为例子的数据</span><br><span class="line">mov bx,data         ;存放处理后数据的空间</span><br><span class="line">mov ds,bx</span><br><span class="line">mov si,0</span><br><span class="line">call dtoc           ;转化为十进制</span><br><span class="line"></span><br><span class="line">mov dh,8            ;显示的位置和样式</span><br><span class="line">mov dl,3</span><br><span class="line">mov cl,2</span><br><span class="line">call show_str</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">dtoc:                   </span><br><span class="line">    push ax             ;在开始转化前的压栈</span><br><span class="line">push bx</span><br><span class="line">push si</span><br><span class="line">push di</span><br><span class="line">mov di,0</span><br><span class="line">mov bx,10</span><br><span class="line"></span><br><span class="line">ahhhh:  </span><br><span class="line">    mov dx,0</span><br><span class="line">div bx</span><br><span class="line">add dx,30h</span><br><span class="line">push dx</span><br><span class="line">mov cx,ax</span><br><span class="line">inc di</span><br><span class="line">jcxz okk</span><br><span class="line">jmp short ahhhh</span><br><span class="line"></span><br><span class="line">okk:    </span><br><span class="line">    mov cx,di</span><br><span class="line">okkk:</span><br><span class="line">    pop ax</span><br><span class="line">mov [si],al</span><br><span class="line">inc si</span><br><span class="line">loop okkk</span><br><span class="line">pop di</span><br><span class="line">pop si</span><br><span class="line">pop bx</span><br><span class="line">pop ax</span><br><span class="line">ret                    ;dotc结束</span><br><span class="line"></span><br><span class="line">show_str:</span><br><span class="line">push ax</span><br><span class="line">push bx</span><br><span class="line">push cx</span><br><span class="line">push dx</span><br><span class="line">push es</span><br><span class="line">push si</span><br><span class="line">push di</span><br><span class="line"></span><br><span class="line">mov ax,0b800h</span><br><span class="line">mov es,ax</span><br><span class="line"></span><br><span class="line">mov al,160</span><br><span class="line">mul dh</span><br><span class="line">mov bx,ax</span><br><span class="line">mov al,2</span><br><span class="line">mul dl</span><br><span class="line">add bx,ax</span><br><span class="line"></span><br><span class="line">mov al,cl</span><br><span class="line">mov ch,0</span><br><span class="line">mov di,0</span><br><span class="line"></span><br><span class="line">showc:  </span><br><span class="line">    mov cl,ds:[si]          ;循环来逐字移动到显示的内存区域</span><br><span class="line">jcxz ok</span><br><span class="line">mov es:[bx+di],cl</span><br><span class="line">mov es:[bx+di+1],al</span><br><span class="line">inc si</span><br><span class="line">add di,2</span><br><span class="line">jmp short showc</span><br><span class="line"></span><br><span class="line">ok:    </span><br><span class="line">    pop di</span><br><span class="line">pop si</span><br><span class="line">pop es</span><br><span class="line">pop dx</span><br><span class="line">pop cx</span><br><span class="line">pop bx</span><br><span class="line">pop ax</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>效果图如下,显示区貌似是直接覆盖的所以多刷了一些回车变成空白页好看一点<br><img src="/2023/07/20/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%8010-12/10.3.png"><br>课程设计1的内容主要参考的网上的代码，在自己写的时候反而不停的发现实验七的代码有问题，所以干脆换成了网上看见的另一个结构或者说思路的数据整理顺序，这里就不贴了。</p><h2 id="第11章"><a href="#第11章" class="headerlink" title="第11章"></a>第11章</h2><h3 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h3><p>标志寄存器用于储存某些指令的执行结果，控制CPU的相关工作方式，按位起作用比如8086CPU的flag寄存器从0到15位中，1，3，5，12，13，14，15均没有作用其他有内容的标志位分别是cf，pf，af，zf，sf，df，of，在debug中有体现<br>zf，零标志位，执行相关指令后结果为0则该标志位内容为1.debug中zr为1，nz为0.<br>pf，奇偶标志位，执行后储存结果的寄存器bit位中1的个数位偶数则为1.debug中pe为1，po为0.<br>sf，符号标志位，执行后结果为负则为1.debug中ng为1，pl为0.<br>cf，进位符号位，无符号运算时向更高位进位或者借位的值则为1.debug中cy为1，nc为0.<br>of，溢出标志位，有符号运算时超出机器表达范围就将产生溢出。debug中ov为1，nv为0.<br>df，方向标志位，控制每次操作后si，di的增减，减少则为1.debug中dn为1，up为0.<br><img src="/2023/07/20/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%8010-12/0.1.png"></p><h3 id="相关指令"><a href="#相关指令" class="headerlink" title="相关指令"></a>相关指令</h3><p>adc是带进位的加法指令，比如 adc ax，3也就是ax&#x3D;ax+3+cf。<br>sbb是带借位减法指令，比如sbb ax，bx 也就是ax&#x3D;ax-bx-cf。<br>cmp是比较指令，相当于减法，不保留结果，只影响标志寄存器的内容<br>转移指令，je（等于则转移，zf&#x3D;1）；jne（不等于，zf&#x3D;0）；jb（低于，cf&#x3D;1）；jnb（不低于，cf&#x3D;0）；ja（高于，cf&#x3D;0且zf&#x3D;0）；jna（不高于，cf&#x3D;1或zf&#x3D;1）.<br>movsb串传送命令，操作为把ds偏移si的内容给es偏移di，而后根据df的值来让si和di减小1或增加1.movsw则为增加或减少2.而同时cld可以将df设置为0，std则为1.<br>rep指令会根据cx的值重复执行后面的串传送指令，可以将rep和movsb一起用来转移或者说复制代码到另一个地方，类rep movsb。<br>pushf将标志寄存器内容压栈，poopf将标志寄存器内容出栈。</p><h3 id="实验11"><a href="#实验11" class="headerlink" title="实验11"></a>实验11</h3><p>把以0结尾的字符串中的小写字母转变为大写字母。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">datasg segment</span><br><span class="line">db &quot;Beginner&#x27;s All-purpose Symbolic Instruction Code.&quot;,0</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:  mov ax,datasg</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,0</span><br><span class="line">call letterc</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">letterc:push cx</span><br><span class="line">mov ch,0</span><br><span class="line"></span><br><span class="line">  s:    mov cl,[si] </span><br><span class="line">jcxz okk</span><br><span class="line"></span><br><span class="line">cmp cl,97    ;97和122为小写字母的范围，如果不在范围则跳转inc si进入下一个字母的循环</span><br><span class="line">jb ok</span><br><span class="line">cmp cl,122</span><br><span class="line">ja ok</span><br><span class="line"></span><br><span class="line">and cl,11011111b</span><br><span class="line">mov [si],cl</span><br><span class="line"></span><br><span class="line">  ok:   inc si</span><br><span class="line">jmp short s</span><br><span class="line">  </span><br><span class="line">  okk:  pop cx</span><br><span class="line">ret</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p><img src="/2023/07/20/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%8010-12/11.1.png"></p><h2 id="第12章"><a href="#第12章" class="headerlink" title="第12章"></a>第12章</h2><h3 id="内中断的产生和处理"><a href="#内中断的产生和处理" class="headerlink" title="内中断的产生和处理"></a>内中断的产生和处理</h3><p>中断也就是CPU在接收到信号后立即对该信号后不继续执行正在执行的程序，转而多信号进行处理，而这个信号被称为中断信息。<br>内中断的中断源有以下四种：除法错误（溢出等），单步执行，执行into指令，执行interesting指令。中断源发出的中断信息中必须包含识别来源的编码，终端类型码为一个字节型数据，可以表示256种中断信息的来源。而根据这个码在内存中的中断向量表找到对应的中断向量，进而通过中断向量前往中断处理程序。对于8086pc机而言中断向量表指定存放在内存地址为0的位置从0000：0000到0000：03FF的1024个单元中存放着中断向量表，但事实上没有这么多的中断向量，部分内存是闲置的。<br>在处理内中断信息时考虑到需要返回继续执行未执行完的代码，所以会在进入处理程序前先保存原本的cs和ip，保存处理程序需要使用的寄存器的值等再处理。完整过程为获得中断码-&gt;标志内存器入栈-&gt;将标志内存器的第8.9位的TF和IF设置为0-&gt;cs，ip先后入栈-&gt;从内存地址为中断类型码<em>4和中断类型码</em>4+2的内存地址读取中断处理程序的入口的ip和cs（<em>4和</em>4+2是因为每个类型都需要两个低位字节存ip两个高位存cs，且完全按照中断码编号分配内存）-&gt;保存用到的寄存器，处理中断，恢复寄存器，iret指令（相当于pop ip，pop cs，popf）返回</p><h3 id="中断处理实例"><a href="#中断处理实例" class="headerlink" title="中断处理实例"></a>中断处理实例</h3><p>除法错误比如溢出时会显示divide overflow作为提醒，显示后返回操作系统中，debug时也就是直接退出debug。<br>单步中断，就好像debug的t命令，再执行t命令时debug会将TF设置为1，再CPU执行完该指令后引发单步中断，再将tf置为0，再执行中断处理程序，所有寄存器内容会被显示在屏幕上。这个时候再回过头看一下在一般执行中断程序前的tf&#x3D;0的步骤有了解释。<br>在响应中断处理时需要注意如果正在设置ss的数据而未设置sp将无法进行中断，因为在中断程序中需要往栈内压入内容但是如果仅设置ss，无法指向一个正确的栈顶。所以在设置ss和sp时需要紧接着设置不然无法中断。回看实验二的内容，为什么那一条指令（mov sp,10）没有显示执行过程。正是因为无法中断。<br><img src="/2023/07/20/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%8010-12/2.1.png"><br>###实验12<br>编写0号中断的处理程序，不知道要怎么调试所以看网上的往里面塞了一段溢出的代码作为调试得到的效果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">    mov ax,cs                       ;以下到call之前都是安装部分</span><br><span class="line">mov ds,ax                       ;这里是将0号的中断处理程序复制到0：200h处</span><br><span class="line">mov si,offset do0</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,200h</span><br><span class="line">mov cx,offset do0end-offset do0 ;直接通过减法得到程序的大小</span><br><span class="line">cld                             ;设置传输方向为正</span><br><span class="line">rep movsb                       </span><br><span class="line"></span><br><span class="line">mov ax,0                        ;将0号中断向量更改为指向本程序编写的地址</span><br><span class="line">mov es,ax</span><br><span class="line">mov word ptr es:[0*4],200h</span><br><span class="line">mov word ptr es:[0*4+2],0</span><br><span class="line"></span><br><span class="line">call mytest</span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line">    mov ax,4c00H</span><br><span class="line">    int 21H</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  do0:  jmp short do0start          ;相当于被打包的行李，通过前面的安装程序放到了内存中</span><br><span class="line">db &quot;divide error!&quot;              ;作为数据不好放在其他地方会被覆盖，所以一起打包了，但是没法执行所以前面jmp掉了</span><br><span class="line"></span><br><span class="line">do0start:</span><br><span class="line">    push ax                         ;在中断处理程序也需要保存备份</span><br><span class="line">    push es</span><br><span class="line">    push di</span><br><span class="line">    push ds</span><br><span class="line">    push si</span><br><span class="line">    push cx</span><br><span class="line"></span><br><span class="line">    mov ax,cs                       ;找到需要输出的字符的位置</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,202h</span><br><span class="line"></span><br><span class="line">mov ax,0b800h                   ;显示出来的步骤</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,12*160+36*2</span><br><span class="line"></span><br><span class="line">mov cx,13</span><br><span class="line"></span><br><span class="line">  s:</span><br><span class="line">    mov al,[si]</span><br><span class="line">mov es:[di],al</span><br><span class="line">inc si</span><br><span class="line">add di,2</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">    pop cx</span><br><span class="line">    pop si</span><br><span class="line">    pop ds</span><br><span class="line">    pop di</span><br><span class="line">    pop es</span><br><span class="line">    pop ax</span><br><span class="line"></span><br><span class="line">mov ax,4c00h                    ;作为一个完整的程序需要结束语</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">mytest:          ;调试程序</span><br><span class="line">    push ax</span><br><span class="line">    push bx</span><br><span class="line"> </span><br><span class="line">    mov ax,1000H    </span><br><span class="line">    mov bl,1H </span><br><span class="line">    div bl      ;产生除法溢出，触发0号中断</span><br><span class="line"> </span><br><span class="line">    pop bx</span><br><span class="line">    pop ax</span><br><span class="line"> </span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">do0end:nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>效果图如下<br><img src="/2023/07/20/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%8010-12/12.1.png"><br>我想起来我可以直接看es的内容，所以把那个调试部分删除了，代码基本没变效果图如下，第一张是未变更状态，第二张是执行后<br><img src="/2023/07/20/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%8010-12/12.3.png"><br><img src="/2023/07/20/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%8010-12/12.2.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;摸鱼的进度确实不太行呢&lt;/p&gt;</summary>
    
    
    
    
    <category term="汇编" scheme="http://librariany.cn/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言7-9自学回顾</title>
    <link href="http://librariany.cn/2023/07/18/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%807-9/"/>
    <id>http://librariany.cn/2023/07/18/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%807-9/</id>
    <published>2023-07-18T03:10:21.000Z</published>
    <updated>2023-08-07T10:34:15.215Z</updated>
    
    <content type="html"><![CDATA[<p>看见满屏花花绿绿我仿佛看见了我太奶</p><span id="more"></span><h2 id="第7章"><a href="#第7章" class="headerlink" title="第7章"></a>第7章</h2><h3 id="and-amp-or-SI-amp-DI-amp-bp"><a href="#and-amp-or-SI-amp-DI-amp-bp" class="headerlink" title="and &amp; or   SI &amp; DI &amp; bp"></a>and &amp; or   SI &amp; DI &amp; bp</h3><p>and指令进行按位与运算，可通过该指令将操作对象对应位设为0。or指令进行按位或运算，可通过改指令将操作对象对应位设为1。这里的按位均按二进制进行。<br>si，di是8086CPU中和bx功能相近的寄存器，不能作为两个8位寄存器来使用。bp也可以作为偏移地址，但是其默认的段地址在ss中。<br>mov ax,[bx+si+idata]中的括号内容也可以有以下表现形式：[bx+200+si]，[200+bx+si]，200[bx][si]，[bx].200[si]，[bx][si]200。即可以用一个变量；一个常量；一个变量+一个常量；两个变量；两个变量+一个常量</p><h3 id="实验6"><a href="#实验6" class="headerlink" title="实验6"></a>实验6</h3><p>编程使得给出的字符串的前四个字母变成大写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ss:stacksg,ds:datasg</span><br><span class="line"></span><br><span class="line">stacksg segment</span><br><span class="line">dw 0,0,0,0,0,0,0,0</span><br><span class="line">stacksg ends</span><br><span class="line"></span><br><span class="line">datasg segment</span><br><span class="line">db &#x27;1. display      &#x27;</span><br><span class="line">db &#x27;2. brows        &#x27;</span><br><span class="line">db &#x27;3. replace      &#x27;</span><br><span class="line">db &#x27;4. modify       &#x27;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start: mov ax,datasg</span><br><span class="line">mov ds,ax</span><br><span class="line"></span><br><span class="line">mov ax,stacksg</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,16</span><br><span class="line"></span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,4</span><br><span class="line">   </span><br><span class="line">   s:   push cx</span><br><span class="line">mov si,0</span><br><span class="line">mov cx,4</span><br><span class="line"></span><br><span class="line">  s0:   mov al,[bx+si+3]   ;因为每行的第一个字母都在第四个，所以+3</span><br><span class="line">and al,11011111b       ;因为ASCII码表中大写与小写的差距，这一位为1则为小写</span><br><span class="line">mov [bx+si+3],al</span><br><span class="line">inc si</span><br><span class="line">loop s0</span><br><span class="line"></span><br><span class="line">add bx,16</span><br><span class="line">pop cx</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>以下为运行中途的结果展示<br><img src="/2023/07/18/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%807-9/6.1.png"></p><h2 id="第8章"><a href="#第8章" class="headerlink" title="第8章"></a>第8章</h2><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>数据可以在三个位置：CPU内部，内存，端口。而表达数据可以有三种概念：立即数（即包含在机器指令中的数据，执行前在CPU的指令缓冲器中），寄存器，段地址和偏移地址（在内存中）。<br>数据的尺寸可以有两种指明方式，1.通过寄存器指明，类似于mov ax,1为字操作mov al,1为字节操作；2.可以用操作符x ptr完成，类似于mov word ptr[bx],1为一个字单元，mov byte ptr [bx],1为一个字节单元。</p><h3 id="div指令"><a href="#div指令" class="headerlink" title="div指令"></a>div指令</h3><p>div是一个除法指令，除数保存在寄存器或者内存单元中，16位的被除数放ax中而32位ax放低16位dx放高16位。结果，8位则al放商，ah放余数；16位则ax放商，dx放余数。<br>格式类div 内存单元&#x2F;寄存器 或者 div byte ptr ds:[0]</p><h3 id="db-dw-dd-amp-dup"><a href="#db-dw-dd-amp-dup" class="headerlink" title="db dw dd &amp; dup"></a>db dw dd &amp; dup</h3><p>在之前定义栈段的时候用过dw，得到的空间为16个字节，而dw也意为为每个数据申请一字的内存，db是一字节，dd是两个字的内存。<br>dup是一个操作符，与db，dw，dd配合使用，用于数据的重复，也就是定义多少个重复的数。格式为db 重复次数 dup （重复的字节型数据） 格式以此类推。例如需要申请一个容量为200和字节的栈段，db 200 dup(0)。</p><h3 id="实验7"><a href="#实验7" class="headerlink" title="实验7"></a>实验7</h3><p>将已有数据按照一定格式存入空间中，并增加一个位置用于储存计算结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ss:stack</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">db &#x27;1975&#x27;,&#x27;1976&#x27;,&#x27;1977&#x27;,&#x27;1978&#x27;,&#x27;1979&#x27;,&#x27;1980&#x27;,&#x27;1981&#x27;,&#x27;1982&#x27;,&#x27;1983&#x27;</span><br><span class="line">db &#x27;1984&#x27;,&#x27;1985&#x27;,&#x27;1986&#x27;,&#x27;1987&#x27;,&#x27;1988&#x27;,&#x27;1989&#x27;,&#x27;1990&#x27;,&#x27;1991&#x27;,&#x27;1992&#x27;</span><br><span class="line">db &#x27;1993&#x27;,&#x27;1994&#x27;,&#x27;1995&#x27;</span><br><span class="line"></span><br><span class="line">dd 16,22,382,1356,2390,8000,16000,244486,50065,97479,140417,197514</span><br><span class="line">dd 345980,590827,803530,1183000,1843000,2759000,3753000,4649000,5937000</span><br><span class="line"></span><br><span class="line">dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226</span><br><span class="line">dw 11542,14430,15257,17800</span><br><span class="line"></span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">table segment</span><br><span class="line">db 21 dup(&#x27;year sume ne ?? &#x27;)</span><br><span class="line">table ends</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">db 8 dup(0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">starts: mov ax,table</span><br><span class="line">mov ds,ax</span><br><span class="line"></span><br><span class="line">mov ax,data</span><br><span class="line">mov es,ax</span><br><span class="line"></span><br><span class="line">mov bx,0</span><br><span class="line">mov si,0   ;year</span><br><span class="line">mov di,84  ;get</span><br><span class="line">mov bp,168 ;num</span><br><span class="line"></span><br><span class="line">mov cx,21</span><br><span class="line"></span><br><span class="line">    S:  mov ax,es:[si]  ;year</span><br><span class="line">mov [bx],ax</span><br><span class="line">add si,2</span><br><span class="line">mov ax,es:[si]</span><br><span class="line">mov [bx].2,ax</span><br><span class="line">add si,2</span><br><span class="line"></span><br><span class="line">mov ax,es:[di]  ;get</span><br><span class="line">mov [bx].5,ax</span><br><span class="line">add di,2</span><br><span class="line">mov ax,es:[di]</span><br><span class="line">mov [bx].7,ax</span><br><span class="line">add di,2</span><br><span class="line"></span><br><span class="line">mov ax,es:[bp]   ;num</span><br><span class="line">mov [bx].10,ax</span><br><span class="line"></span><br><span class="line">mov ax,[bx+5]</span><br><span class="line">mov dx,[bx+7]</span><br><span class="line">div word ptr [bx+10]</span><br><span class="line">mov [bx+13],ax</span><br><span class="line">add bp,2</span><br><span class="line"></span><br><span class="line">add bx,16</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end starts</span><br></pre></td></tr></table></figure><p>下图为效果展示（关于我到了第十章却反复修改了三次这个代码这件事<br><img src="/2023/07/18/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%807-9/7.1.png"></p><h2 id="第9章"><a href="#第9章" class="headerlink" title="第9章"></a>第9章</h2><h3 id="offset"><a href="#offset" class="headerlink" title="offset"></a>offset</h3><p>修改执行指令的顺寻的指令为转移指令，在8086CPU中转移指令分为：无条件转移指令，条件转移指令，循环指令，过程，中断。转移行为分为了只修改IP的段内转移，修改CS和IP的段间转移。<br>操作符offset可以获得标号的偏移地址，比如，mov ax,offset start，ax中会保存start标识位置的相对偏移地址。</p><h3 id="jmp"><a href="#jmp" class="headerlink" title="jmp"></a>jmp</h3><p>jmp short 标号，段内短转移，对IP的修改范围为-128-127，该指令的机器码中不包含转移的目的地而是偏移地址。<br>jmp far ptr 标号，段间转移。机器码中包含目的地址，高地址为段地址，低地址为偏移地址。<br>jmp 寄存器（16位）IP修改为寄存器的内容。<br>jmp word ptr 内存单元地址（段内转移），单元中存放的是目的偏移地址。<br>jmp dword ptr 内存单元地址（段间转移），高地址是转移的目的段地址，低地址是转移的目的偏移地址。</p><h3 id="jcxz-amp-loop"><a href="#jcxz-amp-loop" class="headerlink" title="jcxz &amp; loop"></a>jcxz &amp; loop</h3><p>jcxz是条件转移地址，所有的有条件转移指令都是段转移，对应机器码中包含转移的位移，而不是目的地址，格式：jcxz 标号。转移条件为cx内容&#x3D;&#x3D;0。<br>loop作为循环指令的基础就是loop能根据标号转移，同时cx&#x3D;&#x3D;0也是loop的条件。<br>ps：如果源程序中出现了转移范围越界的问题，在编译时编译器会报错。</p><h3 id="实验8"><a href="#实验8" class="headerlink" title="实验8"></a>实验8</h3><p>分析一个奇怪的程序，运行来观察其实现过程，乍一看代码是真的匪夷所思。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">mov ax,4c00h  ;估计会跳转到这里完成结束</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">start: </span><br><span class="line">    mov ax,0</span><br><span class="line">s:  nop</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">    mov di,offset s     ;这里用di将s所处IP记录了，0008h</span><br><span class="line">mov si,offset s2    ;这里的si记录了s2的偏移地址，0020h</span><br><span class="line">mov ax,cs:[si]      ;将s2地址的机器码给了ax-F6EB，对应jmp 0018h，向上偏移8个字节</span><br><span class="line">mov cs:[di],ax      ;将s2标识的机器码存入了s标识处</span><br><span class="line"></span><br><span class="line">s0: jmp short s         ;即将跳转到0008，debug-u查看0008为jum 0000，向上偏移8个字节</span><br><span class="line"></span><br><span class="line">s1: mov ax,0</span><br><span class="line">int 21h</span><br><span class="line">mov ax,0</span><br><span class="line"></span><br><span class="line">s2: jmp short s1</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以下是过程截图<br><img src="/2023/07/18/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%807-9/8.1.png"><br><img src="/2023/07/18/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%807-9/8.2.png"><br><img src="/2023/07/18/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%807-9/8.3.png"></p><h3 id="实验9"><a href="#实验9" class="headerlink" title="实验9"></a>实验9</h3><p>在画面中间显示要求的花里胡哨的字符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:data</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">db &#x27;welcome to masm!&#x27;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:  </span><br><span class="line">    mov ax,data</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov ax,0b800h  ;在视频内存的情况下，0xB800 是一个常见的地址，用于文本模式下的屏幕显示。它包含一个特殊的显示缓冲区，用于在屏幕上显示文本和字符。</span><br><span class="line">    mov es,ax</span><br><span class="line">mov di,0</span><br><span class="line">mov si,40h</span><br><span class="line"></span><br><span class="line">mov cx,07h</span><br><span class="line">s1: mov ah,00000111b  ;显示的有颜色的字高位存储的是花式</span><br><span class="line">mov al,[di]       ;低地址存储数据</span><br><span class="line">mov es:[780h+si],ax </span><br><span class="line">inc di</span><br><span class="line">add si,2</span><br><span class="line">loop s1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">inc di       ;这里是空格的位置</span><br><span class="line">add si,2</span><br><span class="line"></span><br><span class="line">mov cx,02h</span><br><span class="line">s2: mov ah,00100100b</span><br><span class="line">mov al,[di]</span><br><span class="line">mov es:[780h+si],ax</span><br><span class="line">inc di</span><br><span class="line">add si,2</span><br><span class="line">loop s2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">inc di</span><br><span class="line">add si,2</span><br><span class="line"></span><br><span class="line">mov cx,05h</span><br><span class="line">s3: mov ah,01110001b</span><br><span class="line">mov al,[di]</span><br><span class="line">mov es:[780h+si],ax</span><br><span class="line">inc di</span><br><span class="line">add si,2</span><br><span class="line">loop s3</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>贴一个效果图<br><img src="/2023/07/18/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%807-9/9.2.png"><br>分享一个我不小心把循环的标识写错了的输出效果图，跟吃了菌子一样<br><img src="/2023/07/18/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%807-9/9.1.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;看见满屏花花绿绿我仿佛看见了我太奶&lt;/p&gt;</summary>
    
    
    
    
    <category term="汇编" scheme="http://librariany.cn/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言4-6自学回顾</title>
    <link href="http://librariany.cn/2023/07/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%804-6/"/>
    <id>http://librariany.cn/2023/07/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%804-6/</id>
    <published>2023-07-15T00:43:52.000Z</published>
    <updated>2023-08-07T10:34:16.114Z</updated>
    
    <content type="html"><![CDATA[<p>尝试写程序啦</p><span id="more"></span><h2 id="第4章"><a href="#第4章" class="headerlink" title="第4章"></a>第4章</h2><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>需要用到的工具为文本编译器（如记事本，edit），汇编语言编译程序（进行编译，连接），执行已完成程序的工具程序。在文本程序中写出来的部分成为源程序文件，经过编译器则为可执行文件，也就是从asm到exe。<br>而由于edit和debug等在win11上被取消了，所以安装了dosbox，把相应的工具放在了和代码一个文件夹里。至于ms-dos的相应安装以及配置过程过于繁琐，个人比较推荐dosbox。</p><h3 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h3><p>源程序文件中的所有内容被称为源程序，源程序之所以需要经过编译器才能执行原因有二，一为需要将程序翻译为机器码，二是源程序由汇编指令和伪指令组成，机器不会运行伪指令，而是编译器会运行。源程序执行后成为程序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">       mov ax,0123h</span><br><span class="line">       mov bx,0456h</span><br><span class="line">       add ax,bx</span><br><span class="line"></span><br><span class="line">       mov ax,4c00h</span><br><span class="line">       int 21h</span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>其中<code>assume cs:codesg</code>，<code>codesg segment···codesg ends</code>，<code>end</code>是伪代码，有着不同的功能。<br><code>assume</code>含义为假设，在计算机中所有的内存是连续的，但是在cpu执行时内存被划分为了许多的段，用来存储不同作用的数据。而这里的假设就是假设内存中某个段和源程序中某个段相关联。这个示例中则是让codesg与cs寄存器相联系。<br><code>codesg segment ··· codesg ends</code>这是俩称多使用的伪指令，用于定义一个段，可以是代码，数据，栈等用处的段。codesg则为改段的名称，名称在被编译连接程序处理后作为一个段的地址。segment时开始的标志，ends是段结尾的标志。一个有意义的汇编程序，至少需要一个段。<br><code>end</code>作为程序结束的标志，在编译器编译到end时会停止编译。<br>在汇编源程序中，数据不能以字母开头，比如A000h要写作0A000h。</p><h3 id="编译-连接-执行"><a href="#编译-连接-执行" class="headerlink" title="编译 连接 执行"></a>编译 连接 执行</h3><p>在写好源程序之后会得到一个以asm为后缀的文件，对这个文件进行编译，我使用的时masm配置到dosbox里面的在界面内输入<code>masm 名称.asm</code>如果文件不在所显示的路径中要补充路径。在这之后会有三个回车的确认，第一个是确认asm的文件名，第二个是确认后续连接使用的obj后缀的文件名，第三个是生成的列表文件，第三个回车其实是确认不生成这个中间文件。在这里会有报错提醒，具体定位到源程序文件的行。<br>连接使用的是link，连接会生成可执行文档，同时也会在这一步将包含子函数的库函数该程序进行连接，方便调用。连接的操作则是<code>link 名称.obj</code>，第一个确认是输入的文件名（我的link或许是版本问题，没有这一步），第二个是输出的exe文件名，第三个映像文件（将一系列文件做成单一格式方便下载的文件）同样是中间结果，可以不输出，第四个是连接库函数（我的例子中不需要库函数所以为空），此处的warning不影响后续使用，具体原因学会了补充。<br><img src="/2023/07/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%804-6/0.1.png"><br>执行时需要有一个程序来让我们的程序执行，也就是可执行文件在加载后需要一个程序将CPU的控制权交给该文件，才能让文件得到执行，并且在执行后将CPU的控制权交还，结束执行。而这个交还控制权的操作叫做程序返回。<br>程序返回的实现靠的是源程序中的两条指令。<code>mov ax,4c00h  int 21h</code>，在上面的代码的例子中，这两条指令没有在程序对数据的处理中起作用，他们的作用就体现在了程序返回上。在dos系统上这个让可执行文件执行的文件即为command.com，command根据文件名找到可执行文件后将文件中的程序加载入内存，设置CS:IP指向该程序的入口，随后CPU开始运行该程序，程序结束后又返回command。debug也是由command载入，并在调试结束后返回command。<br>加载程序时会将程序载入一个连续的段内，但是程序的代码与段首有256个字节的距离，这段距离被称为PSP区，主要作用是让dos和被加载系统通讯。</p><h3 id="实验3"><a href="#实验3" class="headerlink" title="实验3"></a>实验3</h3><p>用debug跟进一个程序，查看寄存器内容，栈顶的内容，以及PSP的内容。<br>指令一览<br><img src="/2023/07/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%804-6/3.0.png"><br>查看ds的存储内容可以发现在代码储存空间的段首是以CD 20开头的PSP<br><img src="/2023/07/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%804-6/3.4.png"><br>此处因为<code>mov sp,10</code>，所以sp值改变<br><img src="/2023/07/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%804-6/3.1.png"><br>因为ax，bx值均为0所以ss:sp指向的区域一致在增减00。<br><img src="/2023/07/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%804-6/3.2.png"><br>在<code>int 21h</code>即将执行时需要用p指令来结束程序<br><img src="/2023/07/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%804-6/3.3.png"></p><h2 id="第5章"><a href="#第5章" class="headerlink" title="第5章"></a>第5章</h2><h3 id="bx-amp-段前缀"><a href="#bx-amp-段前缀" class="headerlink" title="[bx] &amp; 段前缀"></a>[bx] &amp; 段前缀</h3><p>[bx]类似于[0]，表示偏移地址，段地址默认为ds。<br>在masm中[1]会被直接作为1，而在debug中会作为[1]进行执行，所以为了在汇编源程序中达到偏移地址的效果，只能用[bx]作为中转，例如 <code>mov ax,[1]</code>需变更为<code>mov bx,1 ；mov ax,[bx]</code>或者标注段寄存器<code>mov ax,ds:[1]</code>。<br>类似于<code>mov ax,ds:[1]</code>的写法还可以拓展到各个访问内存单元的段地址中，ds，cs，ss，es等，类似于<code>mov ax,ss:[bx]</code>这种写法称之为段前缀。<br>需要注意的是有些空间是dos在使用，占用这些空间会造成死机等后果，而dos和其他合法程序一般不会使用0:200-0:2ff的256个字节空间，较为安全，可以用debug查询存储内容以确认安全性。</p><h3 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h3><p>loop的作用可以理解为控制循环，进行的操作有两步：cx&#x3D;cx-1 -&gt; 判断cx值是否为零，否在跳转回标记处，是则退出循环。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">    mov ax,2</span><br><span class="line">    mov cx,11</span><br><span class="line"></span><br><span class="line"> s: add ax,ax</span><br><span class="line">    loop s</span><br><span class="line"></span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>这段代码中的s即为loop指令的标记，cx表示循环执行次数为11次。<br>在debug中可以用p命令将循环一次执行完，用g 加偏移地址可以直接从此处执行到指定地址，类g 0012h。</p><h3 id="实验4"><a href="#实验4" class="headerlink" title="实验4"></a>实验4</h3><p>主要是[bx]以及loop的运用。<br>以下是向内存0:200-0:23F一次传送数据0-63(3fh)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">    mov bx,0020h</span><br><span class="line">    mov ds,bx</span><br><span class="line">    mov ax,0h</span><br><span class="line">    mov cx,64</span><br><span class="line"></span><br><span class="line"> s: mov [ax],al      //用al是因为这里的地址要求按字节传送数据，ax会覆盖 </span><br><span class="line">    inc al</span><br><span class="line">    loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>以下是将<code>mov ax,4cooh</code>之前的指令复制到内存0:200处。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">    mov ax,cs        //cs是代码的起点</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov ax,0020h    </span><br><span class="line">    mov es,ax</span><br><span class="line">    mov bx,0</span><br><span class="line">    mov cx,17h      //这里的17h是在试验后得出的</span><br><span class="line"></span><br><span class="line"> s: mov al,[bx]      </span><br><span class="line">    mov es:[bx],al  </span><br><span class="line">    inc bx</span><br><span class="line">    loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>debubg可以查看到这个代码的全场为cx的初始值，用u可以看到最后两行也就是int 21h那两行的地址，由此可以得到需要复制的代码的长度，则为17h。如下图<br><img src="/2023/07/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%804-6/4.1.png"></p><h2 id="第6章"><a href="#第6章" class="headerlink" title="第6章"></a>第6章</h2><h3 id="定义不同段"><a href="#定义不同段" class="headerlink" title="定义不同段"></a>定义不同段</h3><p>需要用到数据时我们需要在汇编源文件定义这些数据，经过编译，连接后作为程序的一部分写到可执行文件中，这样在程序被载入内存时，数据也获得了存储空间。可以在代码段中定义，比如在用<code>dw 0123h,0456h</code>，dw的意思是定义字型数据。同时也可以在代码段外定义一个新的段，同样用segment标识，还需要在assume标出。<br>也可以定义栈，类<code>dw 0,0,0一共16个0</code>，定义后将获得16个字型数据的空间，在程序中设置ss和sp就可以作为栈来使用。<br>在设置了其他段的情况下，执行代码需要将IP调偏移地址到代码所在，或者用start作为标志。并且在end处标明,end除了通知编译器程序结束以外还可以通知编译器程序的入口在哪里。在编译，连接以后由end start指明的程序入口被转化为一个入口地址，存储在可执行文件的描述信息里面。引用段的地址需要先将地址放入寄存器再mov。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data,ss:stack</span><br><span class="line">.....</span><br><span class="line">code segment</span><br><span class="line">    dw...</span><br><span class="line">start:</span><br><span class="line">.....</span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">emd start</span><br></pre></td></tr></table></figure><h3 id="实验5"><a href="#实验5" class="headerlink" title="实验5"></a>实验5</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data,ss:stack</span><br><span class="line">data segment</span><br><span class="line">    dw 0123h,0456h,0789h,0abch,0defh,0cbah,0987h</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">    dw 0,0,0,0,0,0,0,0</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">starts: mov ax,stack</span><br><span class="line">        mov ss,ax</span><br><span class="line">        mov sp,16</span><br><span class="line"></span><br><span class="line">        mov ax,data</span><br><span class="line">        mov ds,ax</span><br><span class="line"></span><br><span class="line">        push ds:[0]</span><br><span class="line">        push ds:[2]</span><br><span class="line">        pop ds:[2]</span><br><span class="line">        pop ds:[0]</span><br><span class="line"></span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end starts</span><br></pre></td></tr></table></figure><p>确定以CD 20开头的PSP的位置,在100h的偏移以后就是data了<br><img src="/2023/07/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%804-6/5.1.png"><br>栈的定义，不仅需要先占据内存，还要在程序中赋值SS，SP<br><img src="/2023/07/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%804-6/5.2.png"><br><img src="/2023/07/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%804-6/5.3.png"><br>pop和push改变栈内容实录<br><img src="/2023/07/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%804-6/5.4.png"><br>程序返回前ss，cs，ds的内容<br><img src="/2023/07/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%804-6/5.5.png"><br>下一个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data,ss:stack</span><br><span class="line"> </span><br><span class="line">data segment</span><br><span class="line">    dw 0123h,0456h</span><br><span class="line">data ends</span><br><span class="line"> </span><br><span class="line">stack segment</span><br><span class="line">    dw 0,0</span><br><span class="line">stack ends</span><br><span class="line"> </span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">    mov ax,stack      </span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov sp,16         </span><br><span class="line"> </span><br><span class="line">    mov ax,data       </span><br><span class="line">    mov ds,ax</span><br><span class="line"> </span><br><span class="line">    push ds:[0]</span><br><span class="line">    push ds:[2]</span><br><span class="line">    pop ds:[2]</span><br><span class="line">    pop ds:[0]</span><br><span class="line"> </span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>这里的data只给了俩，但是分配内存仍然是16位<br><img src="/2023/07/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%804-6/5.6.png"><br>下一个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">a segment</span><br><span class="line">    db 1,2,3,4,5,6,7,8</span><br><span class="line">a ends</span><br><span class="line"> </span><br><span class="line">b segment</span><br><span class="line">    db 1,2,3,4,5,6,7,8</span><br><span class="line">b ends</span><br><span class="line"> </span><br><span class="line">c segment</span><br><span class="line">    db 0,0,0,0,0,0,0,0</span><br><span class="line">c ends</span><br><span class="line"> </span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">    mov ax,a</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov ax,c</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov bx,0</span><br><span class="line">    mov cx,8</span><br><span class="line"></span><br><span class="line">s1: mov ax,es:[bx]</span><br><span class="line">    mov [bx],ax </span><br><span class="line">    add bx,2</span><br><span class="line">    loop s1</span><br><span class="line"></span><br><span class="line">    mov ax,b</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov bx,0</span><br><span class="line">    mov cx,8</span><br><span class="line"></span><br><span class="line">s2: mov ax,es:[bx]</span><br><span class="line">    add [bx],ax</span><br><span class="line">    add bx,2</span><br><span class="line">    loop s2    </span><br><span class="line"></span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>这里经过了三次循环，主要是为了将a，b段的诗句加在一起保存到c段，有够繁琐的这题，如下图标的就是最后的内容，确实是相加成功了<br><img src="/2023/07/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%804-6/5.7.png"><br>下一个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">a segment</span><br><span class="line"></span><br><span class="line">    dw 1,2,3,4,5,6,7,8</span><br><span class="line"></span><br><span class="line">a ends</span><br><span class="line"></span><br><span class="line">b segment</span><br><span class="line"></span><br><span class="line">    dw 0,0,0,0,0,0,0,0</span><br><span class="line"></span><br><span class="line">b ends</span><br><span class="line"> </span><br><span class="line">code segment</span><br><span class="line"> </span><br><span class="line">start:  mov ax,b</span><br><span class="line">        mov ss,ax</span><br><span class="line">        mov sp,16</span><br><span class="line">mov ax,a</span><br><span class="line">mov ds,ax</span><br><span class="line">mov ax,0</span><br><span class="line">mov cx,8</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">     s: push [bx]  .这里只能用bx，不能用ax</span><br><span class="line">        add bx,2</span><br><span class="line">loop s</span><br><span class="line">    </span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"> </span><br><span class="line">code ends</span><br><span class="line"> </span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>这里用栈的方法做一个逆序，原数据没变，定义的栈是倒序后的结果，定义的段在内存的顺序也是按照定义的顺序来的，偏移的地址也可以按定义顺序计算。<br><img src="/2023/07/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%804-6/5.8.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;尝试写程序啦&lt;/p&gt;</summary>
    
    
    
    
    <category term="汇编" scheme="http://librariany.cn/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言1-3自学回顾</title>
    <link href="http://librariany.cn/2023/07/13/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%801-3/"/>
    <id>http://librariany.cn/2023/07/13/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%801-3/</id>
    <published>2023-07-13T09:07:22.000Z</published>
    <updated>2023-08-07T10:34:16.933Z</updated>
    
    <content type="html"><![CDATA[<p>   汇编语言（第四版）1-3章自学的知识点小结</p><span id="more"></span><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="CPU-amp-总线-amp-存储器"><a href="#CPU-amp-总线-amp-存储器" class="headerlink" title="CPU &amp; 总线 &amp;存储器"></a>CPU &amp; 总线 &amp;存储器</h3><p>CPU作为计算机的核心部件，控制整个计算机的运作并进行运算，运算所需的指令和数据储存在存储器中。而存储器被划分为若干个存储单元，每个存储单元从0开始编号，微型存储器的存储单元为一个字节，即八个二进制位。<br>CPU通过接口板控制外部设备，类似于音响等。<br>CPU读取存储单元地址，命令，数据都需要通过总线完成。总线是一根根导线的集合，从逻辑上分为地址总线，控制总线和数据总线。8根数据总线可以传递一个二进制数据。地址总线的宽度决定了CPU的寻址能力，数据总线，控制总线以此类推。<br>例如，1个CPU的寻址能力为8KB，那么它的地址总线宽度为2^13（也就是13根）。<br>存储器从读写属性上分为随机存储器（RAM）和只读存储器（ROM）。<br>随机存储器可读可写，但带电储存，只读存储器只读不写。<br>CPU在控制存储器时均将其作为内存看待，将其总的看作一个由储存单元构成的逻辑存储器，这个逻辑存储器也就是内存地址空间，每个物理存储器在其中占有一个地址段。</p><h2 id="第二章-寄存器"><a href="#第二章-寄存器" class="headerlink" title="第二章 寄存器"></a>第二章 寄存器</h2><h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><p>一个典型的CPU由运算器，控制器，寄存器等期间构成，由总线连接。<br>8086CPU的所有寄存器都是16位，可以放两个字节，AX，BX，CX，DX存放一般性数据，被称为通用寄存器。<br>以AX为例，AX可以分为两个八位寄存器AH+AL，其中AL为低八位，AH为高八位（字一般由两个字节构成，前半为高八位）。<br>在汇编指令中寄存器名称不分大小写。在汇编指令中可以单独改写AH或者AL的值。</p><h3 id="物理地址-amp-段"><a href="#物理地址-amp-段" class="headerlink" title="物理地址 &amp; 段"></a>物理地址 &amp; 段</h3><p>每个内存单元都有唯一的地址，这个唯一的地址被称为物理地址。8086是16位结构的CPU，但是有20位地址总线，所以8086CPU采用内部结合的方式用两个16位地址合成的方法形成一个20位的物理地址。<br>CPU提供两个16位的地址，一个位段地址，一个位偏移地址，输送进地址加法器。物理地址&#x3D;段地址*16+偏移地址。（计算方法也被称为左移四位，四位是基于数据的存储形式为二进制）（可以类比C语言的指针偏移，或者说C语言的指针偏移基于此）<br>段地址，其段并不是内存分段，而是由CPU划分，段地址是连续的内存单元，一个段的起始地址一定是16的倍数，其最大长度为64KB。例如给定段地址1000H,CPU的偏移地址寻址范围为10000H~1FFFFH。<br>段寄存器存放段地址，8086CPU有四个段寄存器：CS，DS，SS，ES。段寄存器无法直接导入数据，需要通过其他寄存器的中转达成。</p><h3 id="CS-amp-IP"><a href="#CS-amp-IP" class="headerlink" title="CS &amp; IP"></a>CS &amp; IP</h3><p>CS和IP指定了当前CPU要读取命令的地址，CS为代码段寄存器，IP为指令指针寄存器。执行的指令为CS的内容*16+IP的内容（IP也可以理解为读取指令时的偏移值）。<br>命令执行的过程为：读取地址-&gt;地址加法器-&gt;读取指令进入指令缓冲区-&gt;IP值自动增加（读取指令长度为多少IP增加多少）-&gt;执行。<br>8086CPU刚开始工作时CS和IP被设置为CS&#x3D;FFFFH，IP&#x3D;0000H。<br>mov指令不能修改CS,IP的值，可以使用jmp指令进行修改，即：1）jmp 段地址:偏移地址 2）jmp 某一合法寄存器（用寄存器中的值修改IP）。<br>当我们需要将一组内存定义为一个代码段时，要将CS:IP指向所定义的代码段的第一条指令的首地址。</p><h3 id="实验1"><a href="#实验1" class="headerlink" title="实验1"></a>实验1</h3><p>因为win11不支持debug所以需要我安装一个MS-DOS的虚拟机进行实验。<br>Debug的功能R（查看，改变CPU寄存器内容），D（查看内存内容），E（改写内存内容），U（机器指令翻译为汇编指令），T（执行一条机器指令），A（以汇编指令格式在内存写入一条机器指令）等。<br>下图为r，d演示（d的格式为：d 段地址:起始偏移地址 中止地址）<br><img src="/2023/07/13/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%801-3/1.1.png" alt="图片"><br>下图为u演示<br><img src="/2023/07/13/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%801-3/1.2.png" alt="图片"><br>下图为a，t演示<br><img src="/2023/07/13/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%801-3/1.3.png" alt="图片"><br><img src="/2023/07/13/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%801-3/1.4.png" alt="图片"></p><h2 id="第三章-寄存器（内存访问）"><a href="#第三章-寄存器（内存访问）" class="headerlink" title="第三章 寄存器（内存访问）"></a>第三章 寄存器（内存访问）</h2><h3 id="字"><a href="#字" class="headerlink" title="字"></a>字</h3><p>16位寄存器来存储一个字，高八位放高字节，低八位低字节遂需要两个连续地址，这两个连续地址构成的内存单元也称为字单元。某一地址的字单元存放的字节型数据为该地址及下一地址构成的连续地址的数据。<br>16根数据线可以一次性传输16位数据，字节型数据的传送可以在mov指令中给出一个16位的寄存器。也可以给一个8位的寄存器，改变某一地址，改变某一个字的高字节或低字节。<br>下图给出改变ax低字节的示例<br><img src="/2023/07/13/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%801-3/0.1.png" alt="图片"></p><h3 id="mov-amp-add-amp-sub"><a href="#mov-amp-add-amp-sub" class="headerlink" title="mov &amp; add &amp; sub"></a>mov &amp; add &amp; sub</h3><p>mov，可以理解为复制粘贴数据到存储空间，mov ax，bx即为复制bx粘贴到ax。<br>add，为加法，add ax，bx即为把bx的值加到ax上。<br>sub，为减法，sub ax，bx即为在ax上减去bx。<br>mov可以直接将数据放入寄存器，也可以让各个寄存器，内存单元互相放数据，但是不能将数据直接放入段寄存器。mov ax,[0]这个0默认为相对于ds寄存器的偏移地址。</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈是一种规划了长度的有特殊访问方式的存储空间，将一段内存定义为一个段作为栈段，其具有先进后出的特殊模式。栈的操作以字为单位，需要借助SS段寄存器和SP寄存器来完成，SS存放栈顶的段地址(最小地址)，SP存放偏移地址。以此来达到指向栈内有元素的最高位的效果。同样地址计算为SS*16+SP。<br>栈最基本的两个指令为出栈pop和入栈push，两个命令后面可以接寄存器，段寄存器或者内存单元(也就是类 pop [0])，push ax：SP&#x3D;SP-2 -&gt; 将ax内容存入此时SS:SP指向的内存单元，pop ax：将SS:SP指向的内容存入ax -&gt; SP&#x3D;SP+2。<br>在进行操作时，被pop或者push的地址总是SS:SP所指向的地址，所以pop和push对SP的改变先后不同，且是自动改变SP内容。同时由于只修改SP，所以栈顶的最大变化范围为0——FFFFH。<br>pop出栈其实也是一个类似于mov的效果，pop被出栈的地址的数据不会改变，之后在下一次该地址被push时被覆盖。<br>假设栈的空间为10000H——1000FH，空栈时SS:SP会指向栈空间最高地址的下一个单元，即10010H，SS为1000H，SP为0010H。栈满是指向空间的最低地址，即10000H，SP为0000H。<br>由于push和pop只是起到一个地址索引没有对地址惊醒一个限制，所以会导致栈顶超界的问题。比如当SS:SP已经指向栈的最大容量后继续push，就会导致栈规划段以外的地址的数据被覆盖，或者当SS:SP指向的数据已经是空栈状态，继续pop就会pop出其他非栈内数据。</p><h3 id="实验2"><a href="#实验2" class="headerlink" title="实验2"></a>实验2</h3><p>中断机制，即在执行完当前任务后，可以检测到CPU中或外部的某种特殊信息，并立刻对此信息进行处理。<br>以下在debug中演示跳过显示修改SP的命令的过程（中断源是单步执行）。<br><img src="/2023/07/13/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%801-3/2.1.png"><br><img src="/2023/07/13/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%801-3/2.2.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;   汇编语言（第四版）1-3章自学的知识点小结&lt;/p&gt;</summary>
    
    
    
    
    <category term="汇编" scheme="http://librariany.cn/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>close &amp; begin</title>
    <link href="http://librariany.cn/2023/07/12/begin/"/>
    <id>http://librariany.cn/2023/07/12/begin/</id>
    <published>2023-07-12T11:19:56.000Z</published>
    <updated>2023-07-13T01:57:40.059Z</updated>
    
    <content type="html"><![CDATA[<pre><code>关于终于开始用这个早就配置的差不多的博客，结果搞崩又重新配置这件事。</code></pre><span id="more"></span><h2 id="一点碎碎念"><a href="#一点碎碎念" class="headerlink" title="一点碎碎念"></a>一点碎碎念</h2><p>这个博客的搭建其实还蛮讨巧的，没有去弄服务器那些东西，整体的步骤还是比较简单但是还是在三月份花费了我好几天的时间，一个是因为三月份在上课时间本来就不多还有一个原因就是我太菜了。对，没错，我三月份就搭好了这个博客但是现在七月份我才开始写我的第一篇。一开始想着随便写点什么吧，但是又担心自己的技术根本不到呢个够写文章的地步，但是又想到了或许我写文章其实也只是写写自己会些啥，毕竟所有我这一秒学会的东西对于上一秒的我而言都不是件简单事。本来想着要不要段首空两格，好像没什么必要。<br>整个搭建博客的过程其实还是遇见了不少麻烦，包括在我尝试发这第一篇博客的时候也是。但是时间跨度太大了，或许等以后博客用熟悉了可以写一篇博客的<del>食用</del>指南。一开始以为会有蛮多想说的，但是写出来又只有这么一点东西了，那么还是直接开始我对这学年的总结一类的内容吧。毕竟标题是close &amp; begin。</p><h2 id="学年总结"><a href="#学年总结" class="headerlink" title="学年总结"></a>学年总结</h2><p>主要是分为两个部分吧，一个是我总结一下我获得的成绩或者我做出过的努力，另一个是我的反思或者说是对未来的走向的期望。</p><h3 id="专业成绩（计科）"><a href="#专业成绩（计科）" class="headerlink" title="专业成绩（计科）"></a>专业成绩（计科）</h3><p>按照学校的规划或者是人培计划学了以下课程：计算机科学导论，c语言，web设计，高等数学（庆幸都过了，成绩也还将就），数据结构and so on。<br>自学的内容有浅显一点的python的用法和一些零碎的技能。<br>陪跑的比赛太多了就不一一列举了，写两个意思一下：山城杯，大英赛 and so on。</p><h3 id="爱好成绩（辩论）"><a href="#爱好成绩（辩论）" class="headerlink" title="爱好成绩（辩论）"></a>爱好成绩（辩论）</h3><p>概述一下我一年的收获吧。院赛因为疫情没办完，也就不提院赛的成绩了。在下半年的校赛中，智能院拿了善思杯的冠军，我个人是善思杯的佳辩榜第二。在学期末接手了我们院队的队长和校队的副队。</p><h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><p>在专业课上基本是达到了我们学校的中上游水平，但是这远远不够，在下半学年开学的时候就在学的python却一直到军训才差不多学完基础，各种借口导致太拖拉了。在网安方面更是因为诸多的理由没有什么实质性的学习进展，在这个暑假至少要先学会linux的基本运用和汇编语言，并开始学习pwn，顺便给python和数据结构再收个尾。<br>辩论倒是做得还不错，在这个暑假把报名的那几场比赛打好应该就能更进步一点了。不过因为辩论确实也是一件费时间的事情，但是我又舍不得削减辩论只能在之后削减一下其他的娱乐时间，不过辩论对我也算娱乐就是了。既然接下了队长下学期要好好干才行呢。</p>]]></content>
    
    
    <summary type="html">&lt;pre&gt;&lt;code&gt;关于终于开始用这个早就配置的差不多的博客，结果搞崩又重新配置这件事。
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    
    <category term="life" scheme="http://librariany.cn/tags/life/"/>
    
    <category term="study" scheme="http://librariany.cn/tags/study/"/>
    
    <category term="debate" scheme="http://librariany.cn/tags/debate/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://librariany.cn/2023/07/12/hello-world/"/>
    <id>http://librariany.cn/2023/07/12/hello-world/</id>
    <published>2023-07-12T10:56:34.243Z</published>
    <updated>2023-07-12T11:02:58.167Z</updated>
    
    
    
    
    
  </entry>
  
</feed>
