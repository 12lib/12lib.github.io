<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>librarian</title>
  
  
  <link href="http://librariany.cn/atom.xml" rel="self"/>
  
  <link href="http://librariany.cn/"/>
  <updated>2024-11-24T16:10:53.840Z</updated>
  <id>http://librariany.cn/</id>
  
  <author>
    <name>y</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>buuctf_reverse</title>
    <link href="http://librariany.cn/2024/11/18/ctfshow-reverse-1/"/>
    <id>http://librariany.cn/2024/11/18/ctfshow-reverse-1/</id>
    <published>2024-11-17T16:00:00.000Z</published>
    <updated>2024-11-24T16:10:53.840Z</updated>
    
    <content type="html"><![CDATA[<h3 id="勒索病毒"><a href="#勒索病毒" class="headerlink" title="勒索病毒"></a>勒索病毒</h3><p>查壳，32位<br><img src="/2024/11/18/ctfshow-reverse-1/1.0.png"><br>进程序看一眼，发现要打开几个文件，但是事实上我们没有flag文件，只有enflag，而猜测enflag就是加密后的falg，所以把enflag复制改名flag试试<br><img src="/2024/11/18/ctfshow-reverse-1/1.1.png"><br><img src="/2024/11/18/ctfshow-reverse-1/1.2.png"></p><pre><code>a = &quot;DH~mqqvqxB^||zll@Jq~jkwpmvez&#123;&quot;flag = &quot;&quot;for i in range(0,len(a)):    flag += chr(ord(a[i])^31)print(flag)if len(a) == len(flag):    print(&quot;yes&quot;)</code></pre><p>得到如下图的密钥<br><img src="/2024/11/18/ctfshow-reverse-1/1.3.png"><br>运行程序后会发现那个以读模式打开的enflag已经改变了里面就是flag<br><img src="/2024/11/18/ctfshow-reverse-1/1.4.png"><br>![](.&#x2F;ctfshow-reverse-1&#x2F; 1.5.png)<br>（可以发现程序里面似乎有一段很多余的东西，因为这个密钥出来我第一反应是这种纯白字体的报错没见过搜一下</p><h3 id="武穆遗书"><a href="#武穆遗书" class="headerlink" title="武穆遗书"></a>武穆遗书</h3><p>查壳,脱壳，32位<br><img src="/2024/11/18/ctfshow-reverse-1/2.0.png"><br><img src="/2024/11/18/ctfshow-reverse-1/2.1.png"><br><img src="/2024/11/18/ctfshow-reverse-1/2.2.png"><br>进ida看一下<br><img src="/2024/11/18/ctfshow-reverse-1/2.3.png"><br>如果按照正常流程一直分析下去真的很套娃，所以这一题尝试一下动态调试<br><img src="/2024/11/18/ctfshow-reverse-1/2.4.png"><br><img src="/2024/11/18/ctfshow-reverse-1/2.5.png"><br><img src="/2024/11/18/ctfshow-reverse-1/2.6.png"><br><img src="/2024/11/18/ctfshow-reverse-1/2.7.png"><br>断点打在最后的对比字符串这里，然后开始调试，在程序输入123然后回车，回到ida界面中查看<br><img src="/2024/11/18/ctfshow-reverse-1/2.8.png"><br><img src="/2024/11/18/ctfshow-reverse-1/2.9.png"><br>同样的tap操作以后进入伪代码界面，然后可以看见这里的颜色变了，鼠标挪到v4上就可以查看v4的内容了<br><img src="/2024/11/18/ctfshow-reverse-1/2.10.png"><br>flag{fmf_is_great!}</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;勒索病毒&quot;&gt;&lt;a href=&quot;#勒索病毒&quot; class=&quot;headerlink&quot; title=&quot;勒索病毒&quot;&gt;&lt;/a&gt;勒索病毒&lt;/h3&gt;&lt;p&gt;查壳，32位&lt;br&gt;&lt;img src=&quot;/2024/11/18/ctfshow-reverse-1/1.0.png&quot;&gt;&lt;br</summary>
      
    
    
    
    <category term="逆向自学之路" scheme="http://librariany.cn/categories/%E9%80%86%E5%90%91%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="ctf" scheme="http://librariany.cn/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>buuctf-reverse-3</title>
    <link href="http://librariany.cn/2024/07/20/buuctf-reserve-3/"/>
    <id>http://librariany.cn/2024/07/20/buuctf-reserve-3/</id>
    <published>2024-07-20T13:11:49.000Z</published>
    <updated>2024-11-24T16:20:06.011Z</updated>
    
    <content type="html"><![CDATA[<p>buuctf reverse板块部分wp的第三弹，持续更新ing</p><span id="more"></span><h3 id="level-1"><a href="#level-1" class="headerlink" title="level 1"></a>level 1</h3><p>看文件然后甩进ida<br><img src="/2024/07/20/buuctf-reserve-3/1.1.png"><br>进门就是flag进去看一眼<br><img src="/2024/07/20/buuctf-reserve-3/1.2.png"><br>可以看见是将flag.txt文件处理了一下，那么output.txt文件反向操作就可以还原flag了<br><img src="/2024/07/20/buuctf-reserve-3/1.3.png"><br>ctf2020{d9-dE6-20c}<br><img src="/2024/07/20/buuctf-reserve-3/1.4.png"></p><h3 id="re"><a href="#re" class="headerlink" title="re"></a>re</h3><p>看一眼有没有壳<br><img src="/2024/07/20/buuctf-reserve-3/2.1.png"><br>upx 脱一下<br><img src="/2024/07/20/buuctf-reserve-3/2.2.png"><br>ida看一下<br><img src="/2024/07/20/buuctf-reserve-3/2.3.png"><br><img src="/2024/07/20/buuctf-reserve-3/2.4.png"><br>根据判断的逻辑进入sub_4009AE看一下<br><img src="/2024/07/20/buuctf-reserve-3/2.5.png"><br>按照这个逻辑反过来求a，第七位没给只能爆破<br>flag{e165421110ba03099a1c039337}<br><img src="/2024/07/20/buuctf-reserve-3/2.6.png"></p><h3 id="CrackRTF"><a href="#CrackRTF" class="headerlink" title="CrackRTF"></a>CrackRTF</h3><p>照例扫一眼，没壳,32位<br><img src="/2024/07/20/buuctf-reserve-3/3.0.png"><br>看一眼程序，显示需要输入东西<br><img src="/2024/07/20/buuctf-reserve-3/3.1.png"><br>进ida看看，以下图片是分析发现第一段是6位进行了sha-1的加密<br><img src="/2024/07/20/buuctf-reserve-3/3.2.png"><br><img src="/2024/07/20/buuctf-reserve-3/3.3.png"><br>根据加密结果进行爆破</p><pre><code>import hashlibstring = &#39;@DBApp&#39;for i in range(100000, 999999):    flag = str(i) + string    a = hashlib.sha1(flag.encode(&quot;utf8&quot;))    b = a.hexdigest()    if &quot;6e32d0943418c2c33385bc35a1470250dd8923a9&quot; == b:    print(flag)    break</code></pre><p>结果为123321@DBApp<br>继续分析后面的,发现是md5，尝试故技重施，失败了<br><img src="/2024/07/20/buuctf-reserve-3/3.4.png"><br><img src="/2024/07/20/buuctf-reserve-3/3.5.png"><br><img src="/2024/07/20/buuctf-reserve-3/3.6.png"><br>继续往后分析看见另一个40100F,整个函数其实是将一个长度为6的字符串写入了rtf文件，由于从开头开始写入的其实写入以后的内容就是rtf的头文件（虽然我去搜出来的是rtf但是由于长度为6而我自己去看也确实是rtf1）<br><img src="/2024/07/20/buuctf-reserve-3/3.7.png"><br>在写入之前的处理如下图，其实是将AAA的开头和需要的密码异或得到rtf头文件<br><img src="/2024/07/20/buuctf-reserve-3/3.8.png"><br>AAA的开头可以用工具看<br><img src="/2024/07/20/buuctf-reserve-3/3.9.png"></p><pre><code>rtf = &quot;&#123;\\rtf1&quot;c = [0x05,0x7D,0x41,0x15,0x26,0x01]result = &quot;&quot;for i in range(0,6): result += chr(ord(rtf[i])^ord(chr(c[i%6]))) i += 1print(result)</code></pre><p>可得为~!3a@0<br>而前面我们已经发现了在整个程序结束最后一步，这个程序会生成一个rtf文件<br><img src="/2024/07/20/buuctf-reserve-3/3.10.png"><br><img src="/2024/07/20/buuctf-reserve-3/3.11.png"><br>最后得到Flag{N0_M0re_Free_Bugs}</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;buuctf reverse板块部分wp的第三弹，持续更新ing&lt;/p&gt;</summary>
    
    
    
    <category term="逆向自学之路" scheme="http://librariany.cn/categories/%E9%80%86%E5%90%91%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="ctf" scheme="http://librariany.cn/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://librariany.cn/2024/07/13/hello-world/"/>
    <id>http://librariany.cn/2024/07/13/hello-world/</id>
    <published>2024-07-12T16:00:00.000Z</published>
    <updated>2024-07-13T11:55:24.993Z</updated>
    
    <content type="html"><![CDATA[<p>图管异地登陆记</p><span id="more"></span><h2 id="照例开局碎碎念"><a href="#照例开局碎碎念" class="headerlink" title="照例开局碎碎念"></a>照例开局碎碎念</h2><p>换了新电脑紧接着就是一大堆的比赛和期末考，一直没来得及管博客（虽然比赛也没啥收获就是了）。今天终于想起来设置一下两台电脑的同步更新，果不其然是开学驯服MySQL放假驯服hexo。<br>这个hello world纯属巧合，我在部署同步前弄了一个空的博客试试水，不过既然看见了就做个纪念也懒得删这个了。<br>一些过程的截图<br><img src="/2024/07/13/hello-world/3.png"><br><img src="/2024/07/13/hello-world/4.png"><br><img src="/2024/07/13/hello-world/5.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;图管异地登陆记&lt;/p&gt;</summary>
    
    
    
    
    <category term="life" scheme="http://librariany.cn/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>buuctf_reverse -2</title>
    <link href="http://librariany.cn/2024/01/28/buuctf-reserve-2/"/>
    <id>http://librariany.cn/2024/01/28/buuctf-reserve-2/</id>
    <published>2024-01-28T11:37:52.000Z</published>
    <updated>2024-11-18T09:17:43.675Z</updated>
    
    <content type="html"><![CDATA[<p>buuctf reverse板块部分wp的第二弹，持续更新ing</p><span id="more"></span><h3 id="GXYCTF2019-luck-guy"><a href="#GXYCTF2019-luck-guy" class="headerlink" title="[GXYCTF2019]luck_guy"></a>[GXYCTF2019]luck_guy</h3><p>例行查壳，64位的<br><img src="/2024/01/28/buuctf-reserve-2/1.1.png"><br>直接进主函数，然后一路找到flag位置<br><img src="/2024/01/28/buuctf-reserve-2/1.2.png"><br><img src="/2024/01/28/buuctf-reserve-2/1.3.png"><br>输出的是s，而s是由f1和f2位置存储的信息构成的，f1直接点进去就是注释的内容，f2则根据下面的case4，5有关f2的操作来确定内容。f2先是被case4存进内容，而此处\x7F是代表这是16进制，所以逆序存进去之后为注释内容。case5对存进去的字符串进行了处理。<br><img src="/2024/01/28/buuctf-reserve-2/1.4.png"><br>将逆序内容在脚本中进行处理即可得出f2<br><img src="/2024/01/28/buuctf-reserve-2/1.5.png"><br>不得不提的是这个题目和这个答案感觉在给我喂刀，特意搜了一下solar一般表示英俊是男名，我承认ctf比一般的虐文小说好看<br><img src="/2024/01/28/buuctf-reserve-2/1.6.png"></p><h3 id="JustRE"><a href="#JustRE" class="headerlink" title="JustRE"></a>JustRE</h3><p>32位<br><img src="/2024/01/28/buuctf-reserve-2/2.1.png"><br>在字符串搜索没有看见flag和key等，翻了一下看见一个像flag的<br><img src="/2024/01/28/buuctf-reserve-2/2.2.png"><br>交叉引用查看函数<br><img src="/2024/01/28/buuctf-reserve-2/2.3.png"><br>sprintf将内容复制到格式化字符串中，也就是19999和0复制进BDJ中替换%d，存入String<br><img src="/2024/01/28/buuctf-reserve-2/2.4.png"></p><h3 id="刮开有奖"><a href="#刮开有奖" class="headerlink" title="刮开有奖"></a>刮开有奖</h3><p>看一眼，32位<br><img src="/2024/01/28/buuctf-reserve-2/3.1.png"><br>看见security那个函数应该是主函数附近的检查安全性的，点进去看看<br><img src="/2024/01/28/buuctf-reserve-2/3.2.png"><br>进入伪代码<br><img src="/2024/01/28/buuctf-reserve-2/3.3.png"><br>这里的v7-&gt;v16都是连续内存，后面存进了字符，然后sub_4010F0进行处理了，进去看一眼<br><img src="/2024/01/28/buuctf-reserve-2/3.4.png"><br>直接改成c代码看结果。这个地方的dword和<em>4这种表达是因为伪代码从汇编来的，默认为单字节，所以在c代码中注意将a1+i</em>4改为a1[i].<br><img src="/2024/01/28/buuctf-reserve-2/3.5.png"><br><img src="/2024/01/28/buuctf-reserve-2/3.6.png"><br><img src="/2024/01/28/buuctf-reserve-2/3.7.png"><br>if处的string解决了，来看strcmp的内容v4和v5在前面都经过了401000的处理看一眼是啥<br><img src="/2024/01/28/buuctf-reserve-2/3.8.png"><br>%3和后面的跟进看见的字符串猜测为base64，进行base64解码。<br><img src="/2024/01/28/buuctf-reserve-2/3.9.png"><br><img src="/2024/01/28/buuctf-reserve-2/3.10.png"><br><img src="/2024/01/28/buuctf-reserve-2/3.11.png"> <img src="/2024/01/28/buuctf-reserve-2/3.12.png"><br>分析如注释，其中WP已经出现了所以尝试WP1放在前面。<br><img src="/2024/01/28/buuctf-reserve-2/3.13.png"></p><h3 id="简单注册器"><a href="#简单注册器" class="headerlink" title="简单注册器"></a>简单注册器</h3><p>看一眼下载的是安卓的安装包，那么安装试一下看效果<br><img src="/2024/01/28/buuctf-reserve-2/4.1.png"><br><img src="/2024/01/28/buuctf-reserve-2/4.2.png"><br>似乎是根据输入来输出所需要的注册码，进jadx找一下<br><img src="/2024/01/28/buuctf-reserve-2/4.3.png"><br><img src="/2024/01/28/buuctf-reserve-2/4.4.png"><br><img src="/2024/01/28/buuctf-reserve-2/4.5.png"><br>根据搜索到的内容确定位置到这个函数，在这个函数最后他输出了flag<br>这里有两种方式第一种根据第一次if的判断随意编写一个结尾为a，第二位为b长度为32，并且符合第一位加第三位为48+56<br>第二种方式是将第二个if所给出的字符串按照第二个if的规则进行处理直接得到flag<br><img src="/2024/01/28/buuctf-reserve-2/4.6.png"><br><img src="/2024/01/28/buuctf-reserve-2/4.7.png"></p><h3 id="esayre"><a href="#esayre" class="headerlink" title="esayre"></a>esayre</h3><p>首先查壳，发现UPX，去壳<br><img src="/2024/01/28/buuctf-reserve-2/5.1.png"><br><img src="/2024/01/28/buuctf-reserve-2/5.2.png"><br><img src="/2024/01/28/buuctf-reserve-2/5.3.png"><br>进入ida搜索字符串并进入对应函数<br><img src="/2024/01/28/buuctf-reserve-2/5.4.png"><br>根据第一个if可以看见v6为ACTF{flag}的格式，也就是v5数组那部分为flag，接着分析v5友v7v8v9未知数赋值<br>在循环中有一次校验，<code>v4[i] != _data_start__[*((char *)v5 + i) - 1]</code>,反推可得v5：在_data_start__中对应v4[i]的元素的下标加一<br><img src="/2024/01/28/buuctf-reserve-2/5.5.png"><br>查看data那个数组的内容shift+e获取对应的内容<br><img src="/2024/01/28/buuctf-reserve-2/5.6.png"><br>最后获取的数据需要强转为字符(U9X_1S_W6@T?)代码如下：<br>a &#x3D; [42, 70, 39, 34, 78, 44, 34, 40, 73, 63, 43, 64]    &#x2F;&#x2F; v4<br>b &#x3D; [0x7e, 0x7d, 0x7c, 0x7b, 0x7a, 0x79, 0x78, 0x77, 0x76, 0x75, 0x74, 0x73, 0x72, 0x71, 0x70, 0x6f, 0x6e, 0x6d, 0x6c,<br>     0x6b, 0x6a, 0x69, 0x68, 0x67, 0x66, 0x65, 0x64, 0x63, 0x62, 0x61, 0x60, 0x5f, 0x5e, 0x5d, 0x5c, 0x5b, 0x5a, 0x59,<br>     0x58, 0x57, 0x56, 0x55, 0x54, 0x53, 0x52, 0x51, 0x50, 0x4f, 0x4e, 0x4d, 0x4c, 0x4b, 0x4a, 0x49, 0x48, 0x47, 0x46,<br>     0x45, 0x44, 0x43, 0x42, 0x41, 0x40, 0x3f, 0x3e, 0x3d, 0x3c, 0x3b, 0x3a, 0x39, 0x38, 0x37, 0x36, 0x35, 0x34, 0x33,<br>     0x32, 0x31, 0x30, 0x2f, 0x2e, 0x2d, 0x2c, 0x2b, 0x2a, 0x29, 0x28, 0x27, 0x26, 0x25, 0x24, 0x23, 0x20, 0x21, 0x22,<br>     0x00]    &#x2F;&#x2F;data<br>c &#x3D; “”   &#x2F;&#x2F;flag<br>for i in a:<br>    c +&#x3D; chr(b.index(i) + 1)<br>print(c)</p><h3 id="pyre"><a href="#pyre" class="headerlink" title="pyre"></a>pyre</h3><p>首先看看是个pyc文件，直接找工具反编译<br><img src="/2024/01/28/buuctf-reserve-2/6.1.png"><br><img src="/2024/01/28/buuctf-reserve-2/6.2.png"><br>可见flag是一开始的input1，而input1经过处理成为了code所以code一路逆运算就得到了flag{Just_Re_1s_Ha66y!}<br><img src="/2024/01/28/buuctf-reserve-2/6.3.png"></p><h3 id="findit"><a href="#findit" class="headerlink" title="findit"></a>findit</h3><p>首先看一眼文件类型 apk 安装试试<br><img src="/2024/01/28/buuctf-reserve-2/7.1.png"><br><img src="/2024/01/28/buuctf-reserve-2/7.2.png"><br>跟着给出的文本在安装包里面搜索一下<br><img src="/2024/01/28/buuctf-reserve-2/7.3.png"><br>在输出文本前还有一个return和一个输出看来函数没找错<br>可以发现这个分成了两部分分别对x和y进行的处理，最后输出的内容其实只跟第二个灰框内的内容有关，有两种做法<br>第一种分析前半部分得出输入内容，输入到软件中得到flag，第二种直接分析falg（后续为第二种内容的代码）<br><img src="/2024/01/28/buuctf-reserve-2/7.4.png"><br>flag{c164675262033b4c49bdf7f9cda28a75}<br><img src="/2024/01/28/buuctf-reserve-2/7.5.png"></p><h3 id="remo"><a href="#remo" class="headerlink" title="remo"></a>remo</h3><p>首先看一眼，直接放进ida看字符串<br><img src="/2024/01/28/buuctf-reserve-2/8.1.png"><br><img src="/2024/01/28/buuctf-reserve-2/8.2.png"><br>找到correct进来看一眼代码，可以发现核心在两个while上<br><img src="/2024/01/28/buuctf-reserve-2/8.3.png"><br>第二个while在确认第一个while后是否内容为v12相同，那么flag应该是从v12倒推<br>因为%26的存在可以发现这李的处理是将大小写分组以后进行移位处理，所以倒着移位回来就行<br><img src="/2024/01/28/buuctf-reserve-2/8.4.png"><br><img src="/2024/01/28/buuctf-reserve-2/8.5.png"></p><h3 id="rsa"><a href="#rsa" class="headerlink" title="rsa"></a>rsa</h3><p>主要参考了大佬的做法 直接放链接了，后面rsa学好了再另外写rsa解析<br><a href="https://blog.csdn.net/mcmuyanga/article/details/109624988">https://blog.csdn.net/mcmuyanga/article/details/109624988</a></p><h3 id="login"><a href="#login" class="headerlink" title="login"></a>login</h3><p>照例看一眼<br><img src="/2024/01/28/buuctf-reserve-2/10.1.png"><br>进来看代码，其实就是遍历数组右移十三位<br><img src="/2024/01/28/buuctf-reserve-2/10.2.png"><br>flag{<a href="mailto:&#67;&#x6c;&#105;&#101;&#110;&#x74;&#x53;&#x69;&#x64;&#x65;&#76;&#x6f;&#x67;&#105;&#110;&#115;&#65;&#114;&#x65;&#x45;&#x61;&#x73;&#121;&#x40;&#x66;&#108;&#x61;&#x72;&#101;&#x2d;&#x6f;&#x6e;&#x2e;&#x63;&#111;&#109;">&#67;&#x6c;&#105;&#101;&#110;&#x74;&#x53;&#x69;&#x64;&#x65;&#76;&#x6f;&#x67;&#105;&#110;&#115;&#65;&#114;&#x65;&#x45;&#x61;&#x73;&#121;&#x40;&#x66;&#108;&#x61;&#x72;&#101;&#x2d;&#x6f;&#x6e;&#x2e;&#x63;&#111;&#109;</a>}<br><img src="/2024/01/28/buuctf-reserve-2/10.3.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;buuctf reverse板块部分wp的第二弹，持续更新ing&lt;/p&gt;</summary>
    
    
    
    <category term="逆向自学之路" scheme="http://librariany.cn/categories/%E9%80%86%E5%90%91%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="ctf" scheme="http://librariany.cn/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>buuctf_reverse</title>
    <link href="http://librariany.cn/2023/11/06/buuctf-reserve/"/>
    <id>http://librariany.cn/2023/11/06/buuctf-reserve/</id>
    <published>2023-11-06T06:42:26.000Z</published>
    <updated>2024-11-18T09:17:16.156Z</updated>
    
    <content type="html"><![CDATA[<p>buuctf reverse板块的一些write up</p><span id="more"></span><h3 id="reserve1"><a href="#reserve1" class="headerlink" title="reserve1"></a>reserve1</h3><p>先运行程序看看是个什么东西,然后看看是多少位的程序<br><img src="/2023/11/06/buuctf-reserve/1.1.png"><br><img src="/2023/11/06/buuctf-reserve/1.2.png"><br>进入ida，我们在一开始运行该程序的时候看见了输入flag的提示，所以我们可以直接尝试搜索flag字符串，这里用快捷键shift+f12查看字符串，然后搜索字符串。<br><img src="/2023/11/06/buuctf-reserve/1.3.png"><br><img src="/2023/11/06/buuctf-reserve/1.4.png"><br>然后进入我们找到的地方，这里写的错误flag，可见这哥字符串调用附近又flag判断，我们点进去看看，点开后选择交叉引用，进入引用这个的程序处。<br><img src="/2023/11/06/buuctf-reserve/1.5.png"><br><img src="/2023/11/06/buuctf-reserve/1.6.png"><br><img src="/2023/11/06/buuctf-reserve/1.7.png"><br><img src="/2023/11/06/buuctf-reserve/1.8.png"><br>进入这个地方后，我们稍微看看这个逻辑。再引用wrong flag之前有一个分叉，应该是检测是否为正确的flag，调用了strncmp来比对正确flag和输入值。我们可以发现str1是输入，str2按理来讲应该是正确flag，但是hello_world输入不对。所以我们快捷键tab一下，进入伪代码看看怎么个事儿。<br>然后我们就可以发现，这里面在1，2框处都有写道str2.1框是一个简单的比较和if语句。而在2框我们发现这里对str2进行了处理，这里是字符串等于111更换成48，直接r一下查看ASCII表的值。发现是字母o替换成了数字0，所以提交flag{hell0_w0rld}.<br><img src="/2023/11/06/buuctf-reserve/1.9.png"><br><img src="/2023/11/06/buuctf-reserve/1.10.png"></p><h3 id="reserve2"><a href="#reserve2" class="headerlink" title="reserve2"></a>reserve2</h3><p>首先看一下文件类型，是elf文件拖进ida看一眼<br><img src="/2023/11/06/buuctf-reserve/2.1.png"><br>看见flag照样进去看一眼代码<br><img src="/2023/11/06/buuctf-reserve/2.2.png"><br>分析一下发现和上一题一眼是更改了一部分flag,将i和r更换成了1<br><img src="/2023/11/06/buuctf-reserve/2.3.png"><br>去寻找flag所在，在上一个界面进入内存界面,发现flag那个位置附近有一个带有半个括号的类似于flag的东西，将flag后面的78h改为字符发现是另一半括号，提交答案出现啦<br><img src="/2023/11/06/buuctf-reserve/2.4.png"><br><img src="/2023/11/06/buuctf-reserve/2.5.png"><br><img src="/2023/11/06/buuctf-reserve/2.6.png"></p><h3 id="内涵的软件"><a href="#内涵的软件" class="headerlink" title="内涵的软件"></a>内涵的软件</h3><p>首先看一眼壳,没壳。看一眼32位windows.再点开看一眼程序本体<br><img src="/2023/11/06/buuctf-reserve/3.1.png"><br><img src="/2023/11/06/buuctf-reserve/3.2.png"><br>进ida看一眼其代码,可以发现选择Y和N的程序。v4是输入的Y或者N，尝试使用没有被处理的v5作为flag，过了.<br><img src="/2023/11/06/buuctf-reserve/3.3.png"></p><h3 id="新年快乐"><a href="#新年快乐" class="headerlink" title="新年快乐"></a>新年快乐</h3><p>首先查壳，发现有upx,看一眼有壳的ida打开的样子(函数太少啦)，接下来手动去壳<br><img src="/2023/11/06/buuctf-reserve/4.1.png"><br><img src="/2023/11/06/buuctf-reserve/4.2.png"><br>在ollyice中找到壳的位置，然后发现pushad，可以察觉壳就在这里了，跳过壳的内容的代码就能够找到真正的代码内容了。也就是找到popad的内容。<br><img src="/2023/11/06/buuctf-reserve/4.3.png"><br>运行一下，发现只改变了esp和ip那应该就是转到壳的所在准备执行了，然后在这个地方打断点。顺利的发现pop，那么在pop后面设置断点运行到了就能跳过壳啦。<br><img src="/2023/11/06/buuctf-reserve/4.4.png"><br><img src="/2023/11/06/buuctf-reserve/4.5.png"><br><img src="/2023/11/06/buuctf-reserve/4.6.png"><br>然后导出一个新的没有前面的壳的程序，再进入看一眼这个新的1.exe有没有壳，没有啦<br><img src="/2023/11/06/buuctf-reserve/4.7.png"><br><img src="/2023/11/06/buuctf-reserve/4.11.png"><br>脱壳以后的ida正常多了，然后进入查看伪代码，成功发现了有一个作为对比的字符串，是正确的flag。<br><img src="/2023/11/06/buuctf-reserve/4.8.png"><br><img src="/2023/11/06/buuctf-reserve/4.9.png"><br><img src="/2023/11/06/buuctf-reserve/4.10.png"></p><h3 id="XOR"><a href="#XOR" class="headerlink" title="XOR"></a>XOR</h3><p>惯例查壳<br><img src="/2023/11/06/buuctf-reserve/5.1.png"><br>然后看一眼ida的代码,分析一下get_line里面是read函数等一系列东西，应该是在读入写入的数据，后面的比较在strncmp那里，找一找前面有没有处理，发现前面对输入的函数进行了异或，而异或以后和flag比较是相同的话那么flag也是异或以后的。<br><img src="/2023/11/06/buuctf-reserve/5.2.png"><br><img src="/2023/11/06/buuctf-reserve/5.3.png"><br>需要找到falg的位置(strncmp的global,shift+e提取内存的数据)然后还原其本源，而二次异或就会还原未异或的形式，所以写个脚本异或一次找到的flag，然后提交就好了<br><img src="/2023/11/06/buuctf-reserve/5.4.png"><br><img src="/2023/11/06/buuctf-reserve/5.5.png"><br><img src="/2023/11/06/buuctf-reserve/5.6.png"><br><img src="/2023/11/06/buuctf-reserve/5.7.png"><br><img src="/2023/11/06/buuctf-reserve/5.8.png"></p><h3 id="hello-word"><a href="#hello-word" class="headerlink" title="hello word"></a>hello word</h3><p>按照提示这个题目跟第一个easyer差不多，那估计也是直接搜索flag就能看见的东西，然后查看文件时一个apk文件，同样是选择放进ida瞅一眼,不过记得打开要用apk的模式。<br><img src="/2023/11/06/buuctf-reserve/6.1.png"><br><img src="/2023/11/06/buuctf-reserve/6.2.png"><br>字符串搜索flag然后ctrl+t一直找下一个提到flag的位置成功找到flag。<br><img src="/2023/11/06/buuctf-reserve/6.3.png"><br><img src="/2023/11/06/buuctf-reserve/6.4.png"></p><h3 id="reserve3"><a href="#reserve3" class="headerlink" title="reserve3"></a>reserve3</h3><p>常规查壳然后找字符串flag，看源代码<br><img src="/2023/11/06/buuctf-reserve/7.1.png"><br><img src="/2023/11/06/buuctf-reserve/7.2.png"><br><img src="/2023/11/06/buuctf-reserve/7.3.png"><br>这一段其实是对输入的字符串进行了base64的加密然后再按位进行了对ascii码值的增加，所有的该百年做完后与str2进行了对比，str2即为改变后应该有的值<br><img src="/2023/11/06/buuctf-reserve/7.4.png"><br><img src="/2023/11/06/buuctf-reserve/7.5.png"><br>对str2进行按位的减后再base64解密<br><img src="/2023/11/06/buuctf-reserve/7.6.png"></p><h3 id="不一样的flag"><a href="#不一样的flag" class="headerlink" title="不一样的flag"></a>不一样的flag</h3><p>查壳，欸，没有<br><img src="/2023/11/06/buuctf-reserve/8.1.png"><br>来分析代码，首先看见上下左右怀疑是游戏，然后看见说你输入的就是flag那估计flag就是你的路径。<br>在移动部分一共有两个位置在改变一个是v4一个是v3[25]，这两个地方分别对应横向和纵向的移动，那么倒回去看看v3都是些啥，观察发现加上符号25个字符，二符号应该就是开始和地图结束。在继续看exit存在的验证，r一下以后发现碰到1就退出，碰到#就成功，那应该是5*5的迷宫地图。<br>flag就是所走的路径，222441144222。<br>原文链接：<a href="https://blog.csdn.net/qq_43786458/article/details/102407937">https://blog.csdn.net/qq_43786458/article/details/102407937</a><br><img src="/2023/11/06/buuctf-reserve/8.2.png"><br><img src="/2023/11/06/buuctf-reserve/8.3.png"></p><h3 id="simplerev"><a href="#simplerev" class="headerlink" title="simplerev"></a>simplerev</h3><p>例行查壳没有<br><img src="/2023/11/06/buuctf-reserve/9.0.png"><br>查看主函数，发现在选择开始游戏也就是输入d或者D后进入了Dercy，而输入q，Q后会退出程序，所以去分析一下decry。<br><img src="/2023/11/06/buuctf-reserve/9.2.png"><br>直接看整体会发现最后一部分拿text和str2对比，然后去找str2和text，会发现军事金国处理的字符串，str2是在循环中，先看text经过的join函数（此行下第三张图），是两个字符串相和，两个字符串分别是key3和v9。而这两个其实都是直接在这段程序中存入ida的而ida是小端存储所以存储进去后其实是跟看见的顺序是相反的。<br>str2是key转变的，key则是同样由两个字符串合成，同时经过一个过程将所有字母改变为小写。而后面while其实对于大写小写的处理时一致的，只不过是为了防止非字母。<br><img src="/2023/11/06/buuctf-reserve/9.3.png"><br><img src="/2023/11/06/buuctf-reserve/9.4.png"><br><img src="/2023/11/06/buuctf-reserve/9.6.png"><br>所有的目的都是最后经过处理的字符能够变得和text相等，所以直接遍历所有的大小写字符来找出来经过该处理之后相同的是那几个字母。<br><img src="/2023/11/06/buuctf-reserve/9.5.png"></p><h3 id="java逆向解密"><a href="#java逆向解密" class="headerlink" title="java逆向解密"></a>java逆向解密</h3><p>丢进jd-gui查看代码，发现是对输入的密码进行处理后与原密码比较，那么穷举然后经过异或再与key对比即可。或者直接将key逆运算，也就是减去64^0x20.<br><img src="/2023/11/06/buuctf-reserve/10.1.png"><br><img src="/2023/11/06/buuctf-reserve/10.2.png"><br><img src="/2023/11/06/buuctf-reserve/10.3.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;buuctf reverse板块的一些write up&lt;/p&gt;</summary>
    
    
    
    <category term="逆向自学之路" scheme="http://librariany.cn/categories/%E9%80%86%E5%90%91%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="ctf" scheme="http://librariany.cn/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>经典复现之扫雷</title>
    <link href="http://librariany.cn/2023/09/28/%E7%BB%8F%E5%85%B8%E5%A4%8D%E7%8E%B0%E4%B9%8B%E6%89%AB%E9%9B%B7%E4%B8%8A/"/>
    <id>http://librariany.cn/2023/09/28/%E7%BB%8F%E5%85%B8%E5%A4%8D%E7%8E%B0%E4%B9%8B%E6%89%AB%E9%9B%B7%E4%B8%8A/</id>
    <published>2023-09-28T11:29:40.000Z</published>
    <updated>2024-07-13T10:45:54.378Z</updated>
    
    <content type="html"><![CDATA[<p>上半部分为找到扫雷的地图，也就是炸弹信息的存储地。</p><span id="more"></span><h2 id="xdbg查找"><a href="#xdbg查找" class="headerlink" title="xdbg查找"></a>xdbg查找</h2><h3 id="定位查找的函数"><a href="#定位查找的函数" class="headerlink" title="定位查找的函数"></a>定位查找的函数</h3><p>扫雷的游戏界面是一个二维的矩阵，而在某个地方显示图像会需要用到beginpaint并且以endpaint结束。所以尝试去定位此。而猜测扫雷界面一次性显示，使用了双缓存技术，所以可以尝试去定位bitblt。<br>beginpaint：为指定窗口做传输信息的准备，向系统提交显示图像的申请，在beginpaint返回携带显示资源句柄，可以调用函数进行图像显示。<br>endpaint：作为传输结束的标志，因为beginpaint后该显示卡处于独占的状态，需要以此为标志进行释放。<br>双缓存：也就是先在内存准备好需要展示的内容，而后一次性读取显示。<br>bitblt：位块传输，也就是从源头地点中将一个矩形区的图像转到目标地点中同样大小的矩形区。语法为<code>BitBlt (hdcDst, xDst, yDst, cx, cy, hdcSrc, xSrc, ySrc, dwROP) ;</code></p><h3 id="查找过程"><a href="#查找过程" class="headerlink" title="查找过程"></a>查找过程</h3><p>首先是找到这几个的所在地，打断点观察。<br><img src="/2023/09/28/%E7%BB%8F%E5%85%B8%E5%A4%8D%E7%8E%B0%E4%B9%8B%E6%89%AB%E9%9B%B7%E4%B8%8A/1.1.png"><br><img src="/2023/09/28/%E7%BB%8F%E5%85%B8%E5%A4%8D%E7%8E%B0%E4%B9%8B%E6%89%AB%E9%9B%B7%E4%B8%8A/1.2.png"><br><img src="/2023/09/28/%E7%BB%8F%E5%85%B8%E5%A4%8D%E7%8E%B0%E4%B9%8B%E6%89%AB%E9%9B%B7%E4%B8%8A/1.4.png"><br><img src="/2023/09/28/%E7%BB%8F%E5%85%B8%E5%A4%8D%E7%8E%B0%E4%B9%8B%E6%89%AB%E9%9B%B7%E4%B8%8A/1.3.png"><br><img src="/2023/09/28/%E7%BB%8F%E5%85%B8%E5%A4%8D%E7%8E%B0%E4%B9%8B%E6%89%AB%E9%9B%B7%E4%B8%8A/1.5.png"><br>在xdbg中debug，因为断点打在了显示图像的函数上所以一开始窗口显示不出来，执行第三次bitblt才会显示出出窗口。且鼠标移到上面是缓存图标无法点击移动。<br><img src="/2023/09/28/%E7%BB%8F%E5%85%B8%E5%A4%8D%E7%8E%B0%E4%B9%8B%E6%89%AB%E9%9B%B7%E4%B8%8A/1.7.png"><br>运行以后会出现一个基础的页面，在begin运行后出现了计时和计数，可以发现这一部分和扫雷地图是分开加载的。<br><img src="/2023/09/28/%E7%BB%8F%E5%85%B8%E5%A4%8D%E7%8E%B0%E4%B9%8B%E6%89%AB%E9%9B%B7%E4%B8%8A/1.8.png"><br><img src="/2023/09/28/%E7%BB%8F%E5%85%B8%E5%A4%8D%E7%8E%B0%E4%B9%8B%E6%89%AB%E9%9B%B7%E4%B8%8A/1.9.png"><br>而继续运行bitblt发现出现了一个扫雷的格子，已经开始加载地图了。<br><img src="/2023/09/28/%E7%BB%8F%E5%85%B8%E5%A4%8D%E7%8E%B0%E4%B9%8B%E6%89%AB%E9%9B%B7%E4%B8%8A/1.10.png"><br>然后经过单步运行后发现了是在call 后续的bitblt后出现的这个格子，且在此之前入栈了9个未知量。猜测需要的信息就在被入栈的地址中。所以转向去看段地址ebx的内容。<br><img src="/2023/09/28/%E7%BB%8F%E5%85%B8%E5%A4%8D%E7%8E%B0%E4%B9%8B%E6%89%AB%E9%9B%B7%E4%B8%8A/1.11.png"><br>在ebx的内容中给可以看见of，8f，10因为ebx缪按存储的段地址指向的10，后续出现也具有规律，推测是每行的边距。0f个数比较多推测是空白地方，8f是炸弹。而在上面还有一行，63刚好对应99个炸弹数目，1e，10是长宽，后续有待验证。这时虽然没有显示完但是该有的数据都有了，所以可以确定是双缓存。<br><img src="/2023/09/28/%E7%BB%8F%E5%85%B8%E5%A4%8D%E7%8E%B0%E4%B9%8B%E6%89%AB%E9%9B%B7%E4%B8%8A/1.12.png"><br>在全部加载完成后再执行endpaint，而后扫雷界面正常显示，不再出现缓存图标。<br><img src="/2023/09/28/%E7%BB%8F%E5%85%B8%E5%A4%8D%E7%8E%B0%E4%B9%8B%E6%89%AB%E9%9B%B7%E4%B8%8A/1.13.png"><br>点击其中一个方块以后，立刻转到bitblt对界面进行修改，且在尚未显示出来的时候内存中的数字已经发生变化。<br><img src="/2023/09/28/%E7%BB%8F%E5%85%B8%E5%A4%8D%E7%8E%B0%E4%B9%8B%E6%89%AB%E9%9B%B7%E4%B8%8A/1.14.png"><br><img src="/2023/09/28/%E7%BB%8F%E5%85%B8%E5%A4%8D%E7%8E%B0%E4%B9%8B%E6%89%AB%E9%9B%B7%E4%B8%8A/1.16.png"><br>而后在进行单步执行，该处变为41，再执行后扫雷该地区显示出1。而8f地区再点击后也经过过程变成地雷，对于数字的猜测实现。<br><img src="/2023/09/28/%E7%BB%8F%E5%85%B8%E5%A4%8D%E7%8E%B0%E4%B9%8B%E6%89%AB%E9%9B%B7%E4%B8%8A/1.17.png"><br><img src="/2023/09/28/%E7%BB%8F%E5%85%B8%E5%A4%8D%E7%8E%B0%E4%B9%8B%E6%89%AB%E9%9B%B7%E4%B8%8A/1.18.png"><br><img src="/2023/09/28/%E7%BB%8F%E5%85%B8%E5%A4%8D%E7%8E%B0%E4%B9%8B%E6%89%AB%E9%9B%B7%E4%B8%8A/1.19.png"><br><img src="/2023/09/28/%E7%BB%8F%E5%85%B8%E5%A4%8D%E7%8E%B0%E4%B9%8B%E6%89%AB%E9%9B%B7%E4%B8%8A/1.20.png"><br>接下来又开一局对41这个数字进行猜测，在内存显示为42的在图中显示为2.可以认为40为初始值，计算出附近雷的数量后改变内存的值来索引需要显示出的数字的素材。<br><img src="/2023/09/28/%E7%BB%8F%E5%85%B8%E5%A4%8D%E7%8E%B0%E4%B9%8B%E6%89%AB%E9%9B%B7%E4%B8%8A/1.21.png"><br>至此对扫雷的分析差不多结束了。</p><h2 id="CE分析扫雷"><a href="#CE分析扫雷" class="headerlink" title="CE分析扫雷"></a>CE分析扫雷</h2><h3 id="找到可疑的内存地址并分析其内存"><a href="#找到可疑的内存地址并分析其内存" class="headerlink" title="找到可疑的内存地址并分析其内存"></a>找到可疑的内存地址并分析其内存</h3><p>先导入运行中的扫雷程序，并进行初始扫描。<br><img src="/2023/09/28/%E7%BB%8F%E5%85%B8%E5%A4%8D%E7%8E%B0%E4%B9%8B%E6%89%AB%E9%9B%B7%E4%B8%8A/2.1.png"><br>初始扫描后，点击某一个方块，不是雷就扫描变化的，是就扫描不变的，最后锁定到一个地址。目标其实就是找地图所在的区域，变化或者不变化在不同的情况下都有可能在地图中出现，选择其一是为了更简单的找到其所在地。<br><img src="/2023/09/28/%E7%BB%8F%E5%85%B8%E5%A4%8D%E7%8E%B0%E4%B9%8B%E6%89%AB%E9%9B%B7%E4%B8%8A/2.2.png"><br><img src="/2023/09/28/%E7%BB%8F%E5%85%B8%E5%A4%8D%E7%8E%B0%E4%B9%8B%E6%89%AB%E9%9B%B7%E4%B8%8A/2.3.png"><br><img src="/2023/09/28/%E7%BB%8F%E5%85%B8%E5%A4%8D%E7%8E%B0%E4%B9%8B%E6%89%AB%E9%9B%B7%E4%B8%8A/2.4.png"><br><img src="/2023/09/28/%E7%BB%8F%E5%85%B8%E5%A4%8D%E7%8E%B0%E4%B9%8B%E6%89%AB%E9%9B%B7%E4%B8%8A/2.5.png"><br>转向最后一个地址的内存查看，可以发现和xdbg找到的内存是一样的。<br><img src="/2023/09/28/%E7%BB%8F%E5%85%B8%E5%A4%8D%E7%8E%B0%E4%B9%8B%E6%89%AB%E9%9B%B7%E4%B8%8A/2.6.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上半部分为找到扫雷的地图，也就是炸弹信息的存储地。&lt;/p&gt;</summary>
    
    
    
    <category term="逆向自学之路" scheme="http://librariany.cn/categories/%E9%80%86%E5%90%91%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>xdbg食品检测记录之五</title>
    <link href="http://librariany.cn/2023/08/21/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%BA%94/"/>
    <id>http://librariany.cn/2023/08/21/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%BA%94/</id>
    <published>2023-08-21T10:56:26.000Z</published>
    <updated>2024-07-13T10:45:54.340Z</updated>
    
    <content type="html"><![CDATA[<p>串相关</p><span id="more"></span><h3 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp"></a>strcmp</h3><p>strcmp的作用就是两个串之间的比较，如下为编写的源代码<br><img src="/2023/08/21/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%BA%94/1.0.png"><br>如下为主函数<br><img src="/2023/08/21/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%BA%94/1.1.png"><br>其中可以看见在未执行strcmp的时候往栈中存入了两个串的地址，同时又转换存入寄存器方便调用<br><img src="/2023/08/21/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%BA%94/1.2.png"><br>如下为strcmp函数部分<br><img src="/2023/08/21/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%BA%94/1.3.png"><br>首先是取出地址部分然后检测地址是否为空，后续是进行的循环：首先<code>test al, al</code>来判断al是否为空，也就是是否为串的结束部分，不为空继续往后比较大小(<code>shr eax, 10</code>)，大小一样继续比较后面，不一样则跳转执行具体的大小比较(<code>jne ucrtbase.76FB1C48</code>)。循环也就是靠<code>jne ucrtbase.76FB1C10</code>做到，这里的地址就是我们在确定地址不为空的<code>test edx, 3</code>后一句的后一句的地址。<br>这里的test指令其实是将两个内容进行逻辑与的过程类似于and但是不改变两个地方的实际值，只改变寄存器。</p><h3 id="scas-amp-repne"><a href="#scas-amp-repne" class="headerlink" title="scas &amp; repne"></a>scas &amp; repne</h3><p>scasb，scasw，scasd其实也就是对应的byte，word，dword。scasb编译后相当于cmp byte ptr [edi],al 对标志位有影响还会修改寄存器edi的值（df &#x3D; 0，inc edi；df &#x3D; 1，dec edi）。<br>代码如下,略显粗暴<br><img src="/2023/08/21/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%BA%94/2.0.png"><br>未执行到scasb时<br><img src="/2023/08/21/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%BA%94/2.1.png"><br>执行过scasb，edi因为df为0，inc edi<br><img src="/2023/08/21/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%BA%94/2.2.png"><br>repne或者repnz都是一个意思，满足ecx !&#x3D; 0且 zf &#x3D; 0时重复执行其后跟着的指令并将ecx减一（根据b，w，d转换地址），比如repne scasb 重复执行scasb。<br>稍微修改代码，主要是计数这个串的长度<br><img src="/2023/08/21/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%BA%94/3.0.png"><br>刚开始时<br><img src="/2023/08/21/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%BA%94/3.1.png"><br>赋值ecx，al后<br><img src="/2023/08/21/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%BA%94/3.2.png"><br>每次执行scasb导致的edi增加也就是提取的串的字符往后移的过程，移到串的结束符的时候于al的值相同了，zf赋值为1，edi回移；repne不知继续循环。此时的ecx与一开始的差值再减一（结束符的长度）就是串的长度。<br><img src="/2023/08/21/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%BA%94/3.3.png"><br>再改进一下代码增加减一的部分，注释掉的和写出的都可行<br><img src="/2023/08/21/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%BA%94/4.0.png"></p><h3 id="cmps"><a href="#cmps" class="headerlink" title="cmps"></a>cmps</h3><p>相较于scasb，cmpsb的区别就在于比较的是两个串scasb是寄存器和串的比较。同样有cmpsb，cmpsw，cmpsd。<br>代码如下，cmpsb同样可以与repne连用作为循环<br><img src="/2023/08/21/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%BA%94/5.0.png"><br>刚开始<br><img src="/2023/08/21/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%BA%94/5.1.png"><br>将两串赋值给esi和edi寄存器<br><img src="/2023/08/21/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%BA%94/5.2.png"><br>两个串只有2和1的差距，在检测到这个地方后大小就比出来了然后跳出repne继续执行下一条指令<br><img src="/2023/08/21/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%BA%94/5.3.png"><br>用cmpsb来写一个strcmp函数<br><img src="/2023/08/21/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%BA%94/6.0.png"><br>以下是主函数<br><img src="/2023/08/21/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%BA%94/6.1.png"><br>跳转到call strcmp的位置，这里多了一些我在代码里面没写的东西，这是编译器直接加的，如果不想要可以在前面写<code>__declspec(naked)</code>，但是这样寄存器调用前的入栈调用后的出栈还原，堆栈的平衡都要自己写了。<br><img src="/2023/08/21/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%BA%94/6.2.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;串相关&lt;/p&gt;</summary>
    
    
    
    <category term="逆向自学之路" scheme="http://librariany.cn/categories/%E9%80%86%E5%90%91%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>xdbg食品检测记录之四</title>
    <link href="http://librariany.cn/2023/08/17/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E5%9B%9B/"/>
    <id>http://librariany.cn/2023/08/17/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E5%9B%9B/</id>
    <published>2023-08-17T07:49:32.000Z</published>
    <updated>2024-07-13T10:45:54.359Z</updated>
    
    <content type="html"><![CDATA[<p>for &amp; do-while &amp; while 的编译器优化和未优化版本</p><span id="more"></span><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>代码如下<br><img src="/2023/08/17/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E5%9B%9B/1.0.png"><br>无优化版本如下<br><img src="/2023/08/17/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E5%9B%9B/1.1.png"><br>上图第一个框是第一个printf，第二个框是初始化i&#x3D;1，往下是循环的过程，因为初始化在循环外所以循环内是先比较大小再++i。<br>下图是优先大小优化<br><img src="/2023/08/17/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E5%9B%9B/1.2.png"><br>上图肉眼可见的汇编代码变少了，用过程中寄存器和inc能减少程序的大小也可以减少程序的运行时间<br>下图是速度优先的优化，主要是printf的执行过程的区别，优化内存选择了多次出入栈，减少其他内存的申请，优化速度则是直接调用然后改变栈顶位置。<br><img src="/2023/08/17/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E5%9B%9B/1.3.png"></p><h3 id="do-while"><a href="#do-while" class="headerlink" title="do-while"></a>do-while</h3><p>代码如下<br><img src="/2023/08/17/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E5%9B%9B/2.0.png"><br>未优化版本<br><img src="/2023/08/17/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E5%9B%9B/2.1.png"><br>因为判断条件在while处所以跳转指令在最后<br>下图为速度优化（内存优化效果相同，应该是因为代码本身简单<br><img src="/2023/08/17/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E5%9B%9B/2.3.png"><br>这里主要是因为i的初始值和while的判断以及循环的指令过于简单，所以直接由编译器得出了执行程序的结果，直接输出了结果，如果是不给i赋初值就会进行循环</p><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><p>代码如下<br><img src="/2023/08/17/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E5%9B%9B/3.0.png"><br>未优化版本如下<br><img src="/2023/08/17/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E5%9B%9B/3.1.png"><br>优化版本如下<br><img src="/2023/08/17/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E5%9B%9B/3.2.png"><br>也是通过编译器直接计算出了循环的结果，直接将循环结果入栈再打印。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;for &amp;amp; do-while &amp;amp; while 的编译器优化和未优化版本&lt;/p&gt;</summary>
    
    
    
    <category term="逆向自学之路" scheme="http://librariany.cn/categories/%E9%80%86%E5%90%91%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="汇编" scheme="http://librariany.cn/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>xdbg食品检测记录之三</title>
    <link href="http://librariany.cn/2023/08/09/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%B8%89/"/>
    <id>http://librariany.cn/2023/08/09/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%B8%89/</id>
    <published>2023-08-09T07:48:32.000Z</published>
    <updated>2024-07-13T10:45:54.321Z</updated>
    
    <content type="html"><![CDATA[<p>if-else &amp; switch 汇编代码</p><span id="more"></span><h3 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h3><p>if语句，通过判断条件是否成立来决定是否执行后续语句，在汇编中想要不执行语句所用到的功能也就是跳转。执行if的具体的跳转指令还需要根据if的判断条件来看。<br><img src="/2023/08/09/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%B8%89/1.0.png"><br>上面的代码判断条件为 a &gt; b ，那么小于或者等于就会跳转到else执行，用到的指令也就是jle（jmp if less than or equal）。<br><img src="/2023/08/09/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%B8%89/1.1.png"><br>如上图，第一个框是将a，b写入的过程，末尾的判断就是是否跳转到else。<br>在第二个框内无条件跳转指令则是为了不执行else直接跳转到if-else以外。</p><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>switch总体上跟if-else的逻辑一致，不过条件选择多了，变得稍显复杂。<br><img src="/2023/08/09/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%B8%89/2.01.png"><br>下图为写入a的值，方便进行后续比较。虽然只需要一个四字节的寄存器位置存放就可以比较，但在此过程前中esp会多一个四字节位置作为中间变量的位置。<br><img src="/2023/08/09/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%B8%89/2.11.png"><br>这里是三个比较条件和default（最后一个无条件是default），通过跳转执行该条件下的语句。<br><img src="/2023/08/09/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%B8%89/2.12.png"><br>这里是四种情况的执行语句，除了最末尾的default，每个后面都有一个无条件跳转出switch的语句，这样的跳转是因为程序中的break，如果没有break，这里也会从某一板块开始执行完所以条件对应的语句。<br><img src="/2023/08/09/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%B8%89/2.13.png"><br>接下来是关于switch跳转表,已知只有条件比较多才会使用到跳转表。<br><img src="/2023/08/09/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%B8%89/2.02.png"><br>下图中printf下面的框内是存入判断相关的数据并且比较的过程。这里的比较，指的是在条件中最大和最小条件的差值和输入的参数与最小条件的大小差值的比较。在第5排的<code>sub ecx, 10</code>就是输入参数和最小条件的差值（这样通过差值来找也就相当于是偏移，第一个条件的偏移也就是0），倒数第二排的12就是最大和最小条件的差值。<br>当输入参数的差值超过12时不可能是已经给出的条件的任意一条，所以直接执行ja跳转到defualt，这样可以省很多事。当差值不超过时就可以根据差值在跳转表来找具体执行的时哪一部分。<br>往下一个框内,第一行是确定当前的差值；第二行是找到跳转表，而机器码中的44111800就是跳转表地址，按照存储顺序为181144（下一张图中执行到了这一句话可以在汇编代码和内存之间的框里面看见）；第三行则是跳转执行该条件下的语句。<br><img src="/2023/08/09/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%B8%89/2.21.png"><br>如下图，这里可以看见在内存部分标出的内容就是跳转表的内容，条件的排序是按照其case后跟的大小来重新排序后使用的，而最大到自小的条件的内存距离为19，跳转表大小也为19.在跳转表中按照顺序（相减后差值大小，也可以理解为偏移）该位置有case规定的则为是哪一个case（例如：00，01，02），没有的则跳转default（05）.以此来完成switch语句的功能。<br><img src="/2023/08/09/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%B8%89/2.22.png"><br>下图就是对应的在<code>jmp dword ptr ds:[eax*4+&lt;&gt;]</code>后的执行内容刚好4字节就是每个条件需要的大小，其余的调用再通过四字节内的call来实现，每个后面的jmp同样是break的作用。<br><img src="/2023/08/09/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%B8%89/2.23.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;if-else &amp;amp; switch 汇编代码&lt;/p&gt;</summary>
    
    
    
    <category term="逆向自学之路" scheme="http://librariany.cn/categories/%E9%80%86%E5%90%91%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="汇编" scheme="http://librariany.cn/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>xdbg食品检测记录之二（栈相关</title>
    <link href="http://librariany.cn/2023/08/08/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%BA%8C%EF%BC%88%E6%A0%88%E7%9B%B8%E5%85%B3/"/>
    <id>http://librariany.cn/2023/08/08/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%BA%8C%EF%BC%88%E6%A0%88%E7%9B%B8%E5%85%B3/</id>
    <published>2023-08-08T08:39:33.000Z</published>
    <updated>2024-07-13T10:45:54.331Z</updated>
    
    <content type="html"><![CDATA[<p>关于ebp，esp，函数调用约定</p><span id="more"></span><h3 id="esp-amp-ebp"><a href="#esp-amp-ebp" class="headerlink" title="esp &amp; ebp"></a>esp &amp; ebp</h3><p>esp，栈指针寄存器，指向栈顶。ebp基址指针寄存器，指向最靠近0地址的栈的底部。<br>栈顶和最靠近0地址的栈其实是变化的，ebp和esp也是变化的。在调用函数时会开辟新的栈空间用于储存中间产生的数据，在函数调用结束后销毁。同时通过一些方法保证call完成后esp和ebp的值恢复原状。（在执行call的时候也会自行保存eip在ebp保存之前）<br><img src="/2023/08/08/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%BA%8C%EF%BC%88%E6%A0%88%E7%9B%B8%E5%85%B3/1.0.png"><br><img src="/2023/08/08/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%BA%8C%EF%BC%88%E6%A0%88%E7%9B%B8%E5%85%B3/1.2.png"><br><img src="/2023/08/08/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%BA%8C%EF%BC%88%E6%A0%88%E7%9B%B8%E5%85%B3/1.3.png"><br>在函数调用一开始会先储存当前的ebp，并且在最后出栈还原。而在压栈ebp后紧接着将esp的值赋给ebp，这样ebp就指向了上一个栈没存数据的边缘，开辟了新的栈段用于这个被调用的函数。(大概画了下)<br><img src="/2023/08/08/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%BA%8C%EF%BC%88%E6%A0%88%E7%9B%B8%E5%85%B3/1.jpg"></p><h3 id="cdecl"><a href="#cdecl" class="headerlink" title="cdecl"></a>cdecl</h3><p>__cdecl 调用时括号内的参数从右到左入栈，这些参数由调用者清除（手动清栈）。此为c，VC++默认约定，可以在开发环境中修改设置默认，如果带有可变参数的函数必须使用此约定，如printf，scanf。<br>手动清栈，即清栈的代码在调用函数处，不在被调用函数内。清栈的方式则是将栈的栈顶指针esp往回挪（add指令），之后的再次存储会直接覆盖掉前面存储的参数。<br><img src="/2023/08/08/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%BA%8C%EF%BC%88%E6%A0%88%E7%9B%B8%E5%85%B3/2.0.png"><br><img src="/2023/08/08/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%BA%8C%EF%BC%88%E6%A0%88%E7%9B%B8%E5%85%B3/2.1.png"></p><h3 id="stdcall"><a href="#stdcall" class="headerlink" title="stdcall"></a>stdcall</h3><p>API函数调用约定，是c++的标准调用方式，参数从右到左入栈，如果是调用类成员最最后一个入栈this指针。<br>参数由被调用函数在返回后清楚，使用的指令是return x，x标识参数占用的字节数（内存空间大小），CPU据此在ret后自动弹出栈的空间，称为自动清栈。<br><img src="/2023/08/08/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%BA%8C%EF%BC%88%E6%A0%88%E7%9B%B8%E5%85%B3/3.0.png"><br><img src="/2023/08/08/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%BA%8C%EF%BC%88%E6%A0%88%E7%9B%B8%E5%85%B3/3.1.png"></p><h3 id="fastcall"><a href="#fastcall" class="headerlink" title="fastcall"></a>fastcall</h3><p>__fastcall 编译器指定的快速调用方式，其规定将前两个（或几个）参数由寄存器传递（mov指令），其余用堆栈传递，不同的编译器对几个的规定不同。如果调用过多就需要自行平衡，但也是用ret来标记需要清空的栈的空间大小。<br><img src="/2023/08/08/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%BA%8C%EF%BC%88%E6%A0%88%E7%9B%B8%E5%85%B3/4.0.png"><br><img src="/2023/08/08/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%BA%8C%EF%BC%88%E6%A0%88%E7%9B%B8%E5%85%B3/4.1.png"><br><img src="/2023/08/08/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%BA%8C%EF%BC%88%E6%A0%88%E7%9B%B8%E5%85%B3/4.2.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;关于ebp，esp，函数调用约定&lt;/p&gt;</summary>
    
    
    
    <category term="逆向自学之路" scheme="http://librariany.cn/categories/%E9%80%86%E5%90%91%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="汇编" scheme="http://librariany.cn/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>xdbg食品检测记录之一</title>
    <link href="http://librariany.cn/2023/08/04/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%B8%80/"/>
    <id>http://librariany.cn/2023/08/04/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%B8%80/</id>
    <published>2023-08-04T09:49:12.000Z</published>
    <updated>2024-07-13T10:45:54.309Z</updated>
    
    <content type="html"><![CDATA[<p>xdbg使用tips</p><span id="more"></span><h2 id="xdbg"><a href="#xdbg" class="headerlink" title="xdbg"></a>xdbg</h2><p>xdbg有64位和32位两个版本，用来逆向不同位的程序，在编译器里面选择x64配置就是64位，我后续的代码是x86所以用的是x32dbg。<br>先给个我自己语言描述的个窗口功能图吧,具体作用后续展示图来体会。<br><img src="/2023/08/04/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%B8%80/0.0.png"><br>再给个后续经常用到的转到（go to）功能介绍，在编写程序时一些函数库里面的函数（比如printf，messagebox）可以直接被识别，帮助我们在0和1之间找到主函数所在。<br><img src="/2023/08/04/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%B8%80/1.1.png"><br>搜索messageboxw（一般messagebox默认的是w，可以在编写的时候写messageboxa并搜索messageboxa），找到后在命令处打断点并执行到断点处，然后在右下角的堆栈区找到从哪里转到这里来的，然后回车到原来的地方去，那里就是调用这个函数的地方。<br><img src="/2023/08/04/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%B8%80/1.2.png"></p><h2 id="c-嵌入汇编代码"><a href="#c-嵌入汇编代码" class="headerlink" title="c++嵌入汇编代码"></a>c++嵌入汇编代码</h2><p>之所以我的代码都是32位正是因为64位的编译器不允许我嵌入汇编。<br>代码如下。<br><img src="/2023/08/04/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%B8%80/1.0.png"><br>在汇编中找到主函数,这里是通过messageboxa的搜索转到的主函数，因为需要看见主函数的执行所以不是直接挑战看代码，而是让程序一步步执行到messageboxa调用的下一步来，从而回到主函数。我在代码里面为其赋值赋了两次，一次汇编一次c++，而在那个mov指令的框里逆向出来的代码和汇编代码没有差别。<br><img src="/2023/08/04/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%B8%80/1.3.png"><br>上图右边的框里面有汇编代码对应的源程序的位置，这来自于存储了调试信息的pbd文件，删除后就没有了。另外在发布软件时都不会发布debug版本以及pbd文件，所以在生成执行文件时我均采用的release。<br><img src="/2023/08/04/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%B8%80/1.4.png"><br>删除后<br><img src="/2023/08/04/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%B8%80/1.5.png"></p><h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><p>代码如下<br><img src="/2023/08/04/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%B8%80/2.0.png"><br>同样根据messagebox找到主函数所在,并找到add所在。<br>执行的指令所在就是主函数，在压入数值之后的执行指令就是转向了add函数，根据地址（8B1000）或者步进执行过call指令跳转到add函数。add函数也就是编译器执行加法的汇编语言流程，在add函数的末尾可以看见ret指令用于返回主函数。<br><img src="/2023/08/04/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%B8%80/2.3.png"><br>而这个结果是在关闭了编译器自带的代码优化得到的，因为这里的加法可以直接由CPU算出来，调用函数反而会减慢速度。<br>下图是关闭的方法和未关闭的效果。<br><img src="/2023/08/04/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%B8%80/2.2.png"><br><img src="/2023/08/04/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%B8%80/2.1.png"></p><h2 id="寄存器收纳的数据位数"><a href="#寄存器收纳的数据位数" class="headerlink" title="寄存器收纳的数据位数"></a>寄存器收纳的数据位数</h2><p>在写代码时的int short char long代表了数据的长度，分配了内存的长度，接下来用代码来验证一下。<br><img src="/2023/08/04/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%B8%80/3.0.png"><br>eax是32位CPU的寄存器（至少不是一字节大小的），可以储存16进制的222.在第一段汇编代码中的add，没有规定字节大小的默认为一字节所以在逆向汇编时只看得见存储成功的11，word是两字节2211，dword四字节所以44332211.这同样也是前面的代码<br>同样的在第二段汇编代码中，因为赋值的变量在之前用int等定义了所占内存大小，所以成功存储的大小仍然不超过该大小。<br><img src="/2023/08/04/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%B8%80/3.3.png"><br>顺便也看一下第一段汇编代码里面对寄存器内部数据的改变，也就是存储222的eax和存储地址的ebx。<br><img src="/2023/08/04/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%B8%80/3.1.png"><br><img src="/2023/08/04/xdbg%E9%A3%9F%E5%93%81%E6%A3%80%E6%B5%8B%E8%AE%B0%E5%BD%95%E4%B9%8B%E4%B8%80/3.2.png"></p><p>自学的视频来源是<a href="https://www.bilibili.com/video/BV1Jb411p7fU/">https://www.bilibili.com/video/BV1Jb411p7fU/</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;xdbg使用tips&lt;/p&gt;</summary>
    
    
    
    <category term="逆向自学之路" scheme="http://librariany.cn/categories/%E9%80%86%E5%90%91%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="工具" scheme="http://librariany.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>final shell连接超时</title>
    <link href="http://librariany.cn/2023/07/31/final-shell%E8%BF%9E%E6%8E%A5%E8%B6%85%E6%97%B6/"/>
    <id>http://librariany.cn/2023/07/31/final-shell%E8%BF%9E%E6%8E%A5%E8%B6%85%E6%97%B6/</id>
    <published>2023-07-31T04:01:24.000Z</published>
    <updated>2024-07-13T10:45:54.305Z</updated>
    
    <content type="html"><![CDATA[<p>关于我弄了一个傍晚加一个上午的连接这件事</p><span id="more"></span><p>没截图（出问题的时候没想着截图，有缘再，算了这种缘分无福消受），写个大概，问题发生的背景是我的vmware卸载过。<br>在final shell连接的时候显示连接超时，找了教程去修改了虚拟网络编辑器，在更改wmnet8的时候修改了很多次，每次配置更改的小窗显示特别久但是一直没能成功把主机虚拟适配器那个勾选上。<br><img src="/2023/07/31/final-shell%E8%BF%9E%E6%8E%A5%E8%B6%85%E6%97%B6/net.png"><br>后来去搜了一下是因为上一次卸载没卸载干净，所以去下载了ccleaner。把上一次的注册表删完了，顺手还删了一些其他的被检测出来的注册表，我选择了先备个份怕删错。（这个我是直接网上搜的ccleaner官网下的试用装）<br><img src="/2023/07/31/final-shell%E8%BF%9E%E6%8E%A5%E8%B6%85%E6%97%B6/ccleaner.png"><br>到这里大概就可以尝试去虚拟机 ifconfig 找ip了（后续就是我的冤种路线，如果不行可以尝试在网络配置那里恢复默认设置，说不定是之前的影响）。<br>当时我直接冲进来把vmnet8给改了，惯性了属于是。<br>导致我的虚拟机在更改后显示 activation of network connection failed。<br>尝试去打开&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;，然后vim进入ifcfg-ens33，显示这个文件名错误，整个编辑界面是空白的，出问题哩。<br>折腾很久想起来去把网络编辑器还原了默认配置，然后重新config发现正常了，就按照连接final shell的方法，重新连接了一下成功了。<br><img src="/2023/07/31/final-shell%E8%BF%9E%E6%8E%A5%E8%B6%85%E6%97%B6/config.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;关于我弄了一个傍晚加一个上午的连接这件事&lt;/p&gt;</summary>
    
    
    
    
    <category term="linux" scheme="http://librariany.cn/tags/linux/"/>
    
    <category term="倒霉日记" scheme="http://librariany.cn/tags/%E5%80%92%E9%9C%89%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言13-15自学回顾</title>
    <link href="http://librariany.cn/2023/07/25/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%8013-15/"/>
    <id>http://librariany.cn/2023/07/25/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%8013-15/</id>
    <published>2023-07-25T11:27:56.000Z</published>
    <updated>2024-07-13T10:45:54.372Z</updated>
    
    <content type="html"><![CDATA[<p>基本上都直接通过实验的代码分析来回顾。</p><span id="more"></span><h2 id="第13章"><a href="#第13章" class="headerlink" title="第13章"></a>第13章</h2><h3 id="int指令"><a href="#int指令" class="headerlink" title="int指令"></a>int指令</h3><p>int指令也属于内中断的一种，格式为 <code>int n</code> ，其中n为中断类型码，跟前面的中断执行过程差不多，不过直接给出了中断类型码，可以任意指定进行的中断处理程序。执行过程：获取中断类型码n-&gt;标志寄存器入栈，IF&#x3D;0，TF&#x3D;0-&gt;CS,IP入栈-&gt;(IP)&#x3D;(n<em>4),(CS)&#x3D;(n</em>4+2)-&gt;执行处理程序。</p><h3 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h3><p>在系统板上的BIOS（基本输入输出系统）主要提供：硬件系统的检测和初始化程序；外部中断和内部中断的中断例程；用于对硬件设备进行I&#x2F;O操作的中断例程；其他和硬件系统相关的中断例程。操作系统DOS也提供中断例程。<br>BIOS和DOS的中断例程包含了许多子程序，这些子程序实现了程序员在编程的时候常常需要用到的功能。程序员在编程的时候可以直接用int调用其中的中断例程。<br>BIOS和DOS的安装过程为：开机后CPU加电，初始化（CS）&#x3D;0FFFFH，（IP）&#x3D;0，在FFFF：0处有一条跳转指令，执行后进行BIOS的硬件系统检测和初始化程序 -&gt; 初始化程序建立BIOS的中断向量并将入口地址登记在中断向量表 -&gt; 系统硬件检测和初始化完成后调用 int 91h，进行操作系统的应道，计算机交由操作系统 -&gt; DOS启动后还会将其提供的中断例程装入内存，建立中断向量。</p><h3 id="实验13"><a href="#实验13" class="headerlink" title="实验13"></a>实验13</h3><p>1.编写并安装 int 7ch 中断例程，功能为显示一个用0结束的字符串，中断例程安装在0：200处。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">    mov ax,cs               ;将程序复制到0：200h处</span><br><span class="line">mov ds,ax   </span><br><span class="line">mov si,offset new</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,200h</span><br><span class="line">mov cx,offset newend-offset new</span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br><span class="line"></span><br><span class="line">mov ax,0                ;中断向量表</span><br><span class="line">mov es,ax</span><br><span class="line">mov word ptr es:[7ch*4],200h</span><br><span class="line">mov word ptr es:[7ch*4+2],0</span><br><span class="line">    </span><br><span class="line">    mov ax,4c00H</span><br><span class="line">    int 21H</span><br><span class="line"></span><br><span class="line">new:</span><br><span class="line">push ax                 ;中断程序也需要压栈</span><br><span class="line">push bx</span><br><span class="line">push cx</span><br><span class="line">push ds</span><br><span class="line">push es</span><br><span class="line">push si</span><br><span class="line">push di</span><br><span class="line"></span><br><span class="line">mov ax,0b800h           ;显示缓存区</span><br><span class="line">mov es,ax</span><br><span class="line"></span><br><span class="line">mov ax,160              ;dh为行号，160为书上一行的长度，我自己的我没算过</span><br><span class="line">mul dh</span><br><span class="line">mov di,ax</span><br><span class="line"></span><br><span class="line">mov ax,2                ;dl为列好，乘法算显示位置</span><br><span class="line">mul dl</span><br><span class="line">add di,ax</span><br><span class="line"></span><br><span class="line">mov bl,cl               ;cl为颜色</span><br><span class="line"></span><br><span class="line">s:</span><br><span class="line">mov cl,ds:[si]          ;颜色暂存在bl，这里来判断是否为末尾的0</span><br><span class="line">mov ch,0</span><br><span class="line">jcxz ok</span><br><span class="line"></span><br><span class="line">mov es:[di],cl          ;低位数据</span><br><span class="line">mov es:[di+1],bl;高位款式</span><br><span class="line">add di,2</span><br><span class="line"></span><br><span class="line">inc si</span><br><span class="line"></span><br><span class="line">jmp short s</span><br><span class="line"></span><br><span class="line">ok:</span><br><span class="line">pop di                  ;回复原样</span><br><span class="line">pop si</span><br><span class="line">pop es</span><br><span class="line">pop ds</span><br><span class="line">pop cx</span><br><span class="line">pop bx</span><br><span class="line">pop ax</span><br><span class="line"></span><br><span class="line">iret</span><br><span class="line"></span><br><span class="line">newend:nop                  ;方便定位程序的长度，nop没啥实际意义</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>给了个测试程序吧相当于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">db &quot;welcome to masm!&quot;,0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov dh,10</span><br><span class="line">mov dl,10</span><br><span class="line">mov cl,2</span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,0</span><br><span class="line">int 7ch</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>调试结果如下<br><img src="/2023/07/25/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%8013-15/13.1.png"><br>在开始时sp为0000，int 7c后sp被设置并且入栈标志寄存器和CS，IP，并且跳转指令<br><img src="/2023/07/25/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%8013-15/13.2.png"><br>中断例程执行完后栈恢复<br><img src="/2023/07/25/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%8013-15/13.3.png"></p><p>2.编写并安装 int 7ch 中断例程，功能为完成loop指令的功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"> start:</span><br><span class="line">    mov ax,cs               ;将程序放到0：200h</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,offset relo</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,200h</span><br><span class="line">mov cx,offset reloend-offset relo</span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br><span class="line"></span><br><span class="line">mov ax,0                ;中断向量表</span><br><span class="line">mov es,ax</span><br><span class="line">mov word ptr es:[7ch*4],200h</span><br><span class="line">mov word ptr es:[7ch*4+2],0</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line"> relo:</span><br><span class="line">    push bp                 ;将bp原有内容备份</span><br><span class="line">mov bp,sp               ;将现有偏移地址放到bp中</span><br><span class="line">dec cx</span><br><span class="line">jcxz lpret              </span><br><span class="line">add [bp+2],bx           ;bx是在另一个程序中给出来的该程序的调用到需要循环的程序的偏移地址，bp+2就是sp所在地，相加后再次执行时sp就在需要循环的指令处了</span><br><span class="line"></span><br><span class="line"> lpret:</span><br><span class="line">    pop bp                  </span><br><span class="line">iret                    ;如果在循环中返回修改过的cs：ip，80够了就直接往下</span><br><span class="line"> reloend:nop</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>给出的调试的程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"> start:mov ax,0b800h</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,160*12</span><br><span class="line">mov bx,offset s-offset se</span><br><span class="line">mov cx,80</span><br><span class="line"></span><br><span class="line"> s:mov byte ptr es:[di],&#x27;!&#x27;    ;重复80个！</span><br><span class="line">add di,2</span><br><span class="line">int 7ch</span><br><span class="line"></span><br><span class="line"> se:nop</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>效果图<br><img src="/2023/07/25/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%8013-15/13.4.png"></p><p>3.下面的程序，在屏幕的第2，4，6，8行显示4句英文诗</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">s1:db &#x27;Good,better,best,&#x27;,&#x27;$&#x27;</span><br><span class="line">s2: db &#x27;Never let it rest&#x27;,&#x27;$&#x27;</span><br><span class="line">s3: db &#x27;Till good is better&#x27;,&#x27;$&#x27;</span><br><span class="line">s4: db &#x27;And better,best.&#x27;,&#x27;$&#x27;</span><br><span class="line">s : dw offset s1,offset s2,offset s3,offset s4</span><br><span class="line">row: db 2,4,6,8</span><br><span class="line"></span><br><span class="line">strat:</span><br><span class="line">mov ax,cs               ;找到数据的段地址</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,offset s         ;找到每句话的偏移地址</span><br><span class="line">mov si,offset row       ;存储的显示行</span><br><span class="line">mov cx,4</span><br><span class="line">ok:</span><br><span class="line">mov bh,0                ;行号</span><br><span class="line">mov dh,[si]</span><br><span class="line">mov dl,0                ;列号</span><br><span class="line">mov ah,2                ;在int 10h中ah，9为放置光标</span><br><span class="line">int 10h</span><br><span class="line"></span><br><span class="line">mov dx,[bx]             ;ds:dx指向字符串</span><br><span class="line">mov ah,9                ;int 21h中在光标处显示字符</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">inc si                  ;指向下一个字符串</span><br><span class="line">add bx,2</span><br><span class="line">loop ok</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end strat</span><br></pre></td></tr></table></figure><p>效果图<br><img src="/2023/07/25/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%8013-15/13.5.png"></p><h2 id="第14章"><a href="#第14章" class="headerlink" title="第14章"></a>第14章</h2><h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>在pc机上各种接卡口，主板上的接口芯片，其他芯片等都与CPU总线相连，CPU通过控制线向他们所在芯片发出端口读写指令。在CPU角度，将这些寄存器都当作端口，对他们进行统一编址，从而建立统一的端口地址空间。<br>端口的读写指令只有两条：in，out分别为从端口读取和向端口写入。在读取和写入时只能用ax或者al来存放数据，8位端口用al，16位用ax。</p><h3 id="shr-amp-shl"><a href="#shr-amp-shl" class="headerlink" title="shr &amp; shl"></a>shr &amp; shl</h3><p>shr和shl为逻辑移位符，shr为右移，shl左移。<code>shl 1</code>为例：将一个寄存器或者内存单元中的数据左移一位-&gt;将最后移出的一位写入CF中-&gt; 缺失位补0。</p><h3 id="实验14"><a href="#实验14" class="headerlink" title="实验14"></a>实验14</h3><p>以“年&#x2F;月&#x2F;日 时:分:秒”的格式，显示当前日期时间。在CMOS RAM中实时钟存储时间的单元为秒0分2时4日7月8年9。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">db &quot;/&quot;,&#x27; &#x27;,&#x27;:&#x27;      ;需要用到的符号</span><br><span class="line">db 9,8,7,4,2,0      ;因为储存顺序原因，直接按顺序存储单元位置</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"> start:mov ax,data     ;找到数据存储位置</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,3            ;单元的位移</span><br><span class="line">mov bx,0b800h       ;显示缓存区</span><br><span class="line">mov es,bx</span><br><span class="line">mov di,0            ;符号的位移</span><br><span class="line">mov cx,3</span><br><span class="line"></span><br><span class="line"> s:push cx             ;先存储cx内容后续需要使用cl</span><br><span class="line">mov al,ds:[si]      ;在CMOS中读取</span><br><span class="line">out 70h,al</span><br><span class="line">in al,71h</span><br><span class="line"></span><br><span class="line">mov ah,al           ;处理读出的8位的数据，8位分成4位存储了两个数据，高位为十位</span><br><span class="line">mov cl,4</span><br><span class="line">shr ah,cl</span><br><span class="line">and al,00001111b</span><br><span class="line"></span><br><span class="line">add ah,30h          ;数字变成ASCII码表的对应</span><br><span class="line">add al,30h</span><br><span class="line"></span><br><span class="line">mov byte ptr es:[160*12+40*2+di],ah     ;分别显示高低位的数据</span><br><span class="line">mov byte ptr es:[160*12+40*2+2+di],al</span><br><span class="line"></span><br><span class="line">mov al,ds:[0]                           ;显示符号</span><br><span class="line">mov byte ptr es:[160*12+40*2+4+di],al</span><br><span class="line"></span><br><span class="line">inc si</span><br><span class="line">add di,6</span><br><span class="line">pop cx</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov al,ds:[1]                           ;将上一个/替换为空格</span><br><span class="line">mov byte ptr es:[160*12+40*2+16],al</span><br><span class="line">add di,2</span><br><span class="line"></span><br><span class="line">mov cx,3                                ;操作流程同上</span><br><span class="line"></span><br><span class="line"> s1:push cx</span><br><span class="line">mov al,ds:[si]</span><br><span class="line">out 70h,al</span><br><span class="line">in al,71h</span><br><span class="line"></span><br><span class="line">mov ah,al</span><br><span class="line">mov cl,4</span><br><span class="line">shr ah,cl</span><br><span class="line">and al,00001111b</span><br><span class="line"></span><br><span class="line">add ah,30h</span><br><span class="line">add al,30h</span><br><span class="line"></span><br><span class="line">mov byte ptr es:[160*12+40*2+di],ah</span><br><span class="line">mov byte ptr es:[160*12+40*2+2+di],al</span><br><span class="line"></span><br><span class="line">mov al,ds:[2]</span><br><span class="line">mov byte ptr es:[160*12+40*2+4+di],al</span><br><span class="line"></span><br><span class="line">inc si</span><br><span class="line">add di,6</span><br><span class="line">pop cx</span><br><span class="line">loop s1</span><br><span class="line"></span><br><span class="line">mov al,ds:[1]</span><br><span class="line">mov byte ptr es:[160*12+40*2+36],al</span><br><span class="line">add di,2</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>效果图<br><img src="/2023/07/25/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%8013-15/14.1.png"><br>看一个我忘了push cx导致的错误示范图,蛮好玩的<br><img src="/2023/07/25/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%8013-15/14.0.png"></p><h2 id="第15章"><a href="#第15章" class="headerlink" title="第15章"></a>第15章</h2><h3 id="外中断"><a href="#外中断" class="headerlink" title="外中断"></a>外中断</h3><p>CPU的外部有需要处理的事情发生时会产生外中断的中断信息，外中断源有两种：可屏蔽中断，不可屏蔽中断。<br>可屏蔽中断的判断为IF&#x3D;1，则在执行完该指令后中断。在中断过程中将IF置0就是为了防止其他可屏蔽中断。而sti指令可以将IF&#x3D;1；cli指令可以将IF&#x3D;0.</p><h3 id="PC机的键盘输入"><a href="#PC机的键盘输入" class="headerlink" title="PC机的键盘输入"></a>PC机的键盘输入</h3><p>键盘的每个键相当于一个开关，按下和松开产生扫描码，按下称为通码，松开称为断码。断码&#x3D;通码+80h。扫描码会被送往60h端口，键盘的输入到达60h后相关芯片会往CPU发出中断类型码为9的可屏蔽中断信息。</p><h3 id="实验15"><a href="#实验15" class="headerlink" title="实验15"></a>实验15</h3><p>安装一个 int 9h ，效果为按下‘A’后再松开就会出现满屏‘A’。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">db 128 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"> start:mov ax,stack</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,128</span><br><span class="line"></span><br><span class="line">push cs</span><br><span class="line">pop ds</span><br><span class="line"></span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line"></span><br><span class="line">mov si,offset int9          ;安装int 9h程序</span><br><span class="line">mov di,204h</span><br><span class="line">mov cx,offset int9end - offset int9</span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br><span class="line"></span><br><span class="line">push es:[9*4]               ;通过栈存储原int 9h的内容，方便后续调用</span><br><span class="line">pop es:[200h]</span><br><span class="line">push es:[9*4+2]</span><br><span class="line">pop es:[202h]</span><br><span class="line"></span><br><span class="line">cli </span><br><span class="line">mov word ptr es:[9*4],204h      ;中断向量表</span><br><span class="line">mov word ptr es:[9*4+2],0h</span><br><span class="line">sti</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line"> int9:</span><br><span class="line">    push ax                         ;备份</span><br><span class="line">push bx</span><br><span class="line">push cx</span><br><span class="line">push es</span><br><span class="line"></span><br><span class="line">in al,60h                       ;指定60h端口</span><br><span class="line"></span><br><span class="line">pushf                           ;简化后成果具体看末尾</span><br><span class="line">call dword ptr cs:[200h]</span><br><span class="line"></span><br><span class="line">cmp al,9eh                      ;检测断码</span><br><span class="line">jne int9ret</span><br><span class="line"></span><br><span class="line">mov ax,0b800h                   ;输出满屏A</span><br><span class="line">mov es,ax</span><br><span class="line">mov bx,0</span><br><span class="line">mov ah,41h</span><br><span class="line">mov cx,2000</span><br><span class="line"></span><br><span class="line"> s:mov es:[bx],ah</span><br><span class="line">add bx,2</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line"> int9ret:</span><br><span class="line">pop es                          ;回档原来的寄存器</span><br><span class="line">pop cx</span><br><span class="line">pop bx</span><br><span class="line">pop ax</span><br><span class="line">iret</span><br><span class="line"></span><br><span class="line"> int9end:nop</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>关于简化的部分是在模拟原来的int指令的调用过程，因为此处调用的原int 9h已经不是int指令了。即取中断类型码-&gt;标志寄存器入栈-&gt;IF,TF置零-&gt;CS,IP入栈-&gt;跳转指令。<br>最后两步和call指令效果类似，标志寄存器入栈可以用pushf，对于置零可以由一下指令完成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pushf</span><br><span class="line">pop ax</span><br><span class="line">and ah,11111100b</span><br><span class="line">push ax</span><br><span class="line">popf</span><br></pre></td></tr></table></figure><p>由于在上面的程序中已经在进入中断程序时将IF，TF置零了，不需要这一堆只用pushf和call。<br>效果图如下,图一为按住A不放，图二为放开后<br><img src="/2023/07/25/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%8013-15/15.1.png"><br><img src="/2023/07/25/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%8013-15/15.2.png"><br>说真的边敲代码边开着饭拍的凤凰传奇音乐节live非常提神醒脑，美中不足是没办法控制抖腿。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;基本上都直接通过实验的代码分析来回顾。&lt;/p&gt;</summary>
    
    
    
    <category term="《汇编语言》自学之路" scheme="http://librariany.cn/categories/%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="汇编" scheme="http://librariany.cn/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言10-12自学回顾</title>
    <link href="http://librariany.cn/2023/07/20/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%8010-12/"/>
    <id>http://librariany.cn/2023/07/20/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%8010-12/</id>
    <published>2023-07-20T02:48:40.000Z</published>
    <updated>2024-07-13T10:45:54.370Z</updated>
    
    <content type="html"><![CDATA[<p>摸鱼的进度确实不太行呢</p><span id="more"></span><h2 id="第10章"><a href="#第10章" class="headerlink" title="第10章"></a>第10章</h2><h3 id="ret-amp-retf-amp-call"><a href="#ret-amp-retf-amp-call" class="headerlink" title="ret &amp; retf &amp; call"></a>ret &amp; retf &amp; call</h3><p>ret指令可以用栈中的数据修改IP内容，retf则可以用栈中数据修改CS和IP从而实现转移。操作也就相当于令ip和cs等于栈顶元素然后再将栈顶元素出栈。<br>call指令也是跳转指令，先将ip或者cs和ip压入栈（先cs后ip）再转移到指定的偏移地址。而这个偏移位移&#x3D;标号处的地址减去call后第一个指令的地址。也就是先把call指令放入缓存区将当前ip移到下一条指令后执行转移。<br>格式有：call 16位寄存器 入栈ip；call far ptr 标号 入栈cs,ip段间转移；call word ptr 内存单元地址 入栈ip；call dword ptr 内存单元地址 入栈cs，ip。<br>可以通过call一个标识，在标识内写入函数，并在最后通过ret返回的方式以栈作为中转来实现函数调用。</p><h3 id="mul"><a href="#mul" class="headerlink" title="mul"></a>mul</h3><p>mul是乘法指令，格式为：mul reg ，两个相乘的需要是两哥位数相同的寄存器，如果是8位默认将给出的寄存器与al相乘，16位则是和ax相乘。8位的结果保存在ax中，16位低位在ax高位在dx。</p><h3 id="实验10"><a href="#实验10" class="headerlink" title="实验10"></a>实验10</h3><p>1.显示字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">data segment</span><br><span class="line">db &#x27;Welcome to masm!&#x27;,0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:  mov dh,15   ;8行太靠前了</span><br><span class="line">mov dl,25       ;3列也是</span><br><span class="line">mov cl,2        ;决定字的样式</span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,0</span><br><span class="line">call show_str</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">show_str:       </span><br><span class="line">push ax        ;在子函数中调用寄存器的时候为了避免寄存器冲突，全部入栈一遍</span><br><span class="line">push bx</span><br><span class="line">push cx</span><br><span class="line">push dx</span><br><span class="line">push es</span><br><span class="line">push si</span><br><span class="line">push di</span><br><span class="line"></span><br><span class="line">mov ax,0b800h</span><br><span class="line">mov es,ax</span><br><span class="line"></span><br><span class="line">mov al,160</span><br><span class="line">mul dh</span><br><span class="line">mov bx,ax</span><br><span class="line">mov al,2</span><br><span class="line">mul dl</span><br><span class="line">add bx,ax</span><br><span class="line"></span><br><span class="line">mov al,cl</span><br><span class="line">mov ch,0</span><br><span class="line">mov di,0</span><br><span class="line"></span><br><span class="line">showc:  mov cl,ds:[si]</span><br><span class="line">jcxz ok</span><br><span class="line">mov es:[bx+di],cl</span><br><span class="line">mov es:[bx+di+1],al</span><br><span class="line">inc si</span><br><span class="line">add di,2</span><br><span class="line">jmp short showc</span><br><span class="line"></span><br><span class="line">ok:     pop di</span><br><span class="line">pop si</span><br><span class="line">pop es</span><br><span class="line">pop dx</span><br><span class="line">pop cx</span><br><span class="line">pop bx</span><br><span class="line">pop ax</span><br><span class="line">ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>效果如下<br><img src="/2023/07/20/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%8010-12/10.1.png"><br>2.解决除法溢出，将除法分解为高低位分别计算: x&#x2F;n&#x3D;int(高位&#x2F;n)<em>65536+(rem(高位&#x2F;n</em>65536)+低位)&#x2F;n</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:  mov ax,4240h</span><br><span class="line">mov dx,00fh</span><br><span class="line">mov cx,0ah</span><br><span class="line">call divdw</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">divdw:  mov bx,ax</span><br><span class="line">mov ax,dx</span><br><span class="line">mov dx,0</span><br><span class="line">div cx      ;高位部分的除法，商本来就在高位存放，余数在低位继续除法</span><br><span class="line">mov si,ax   ;ax存储商dx存储余数</span><br><span class="line"></span><br><span class="line">mov ax,bx   ;重新把低位给放回ax和上一次除法储存在dx的余数作为高位完成除法</span><br><span class="line">div cx</span><br><span class="line"></span><br><span class="line">mov cx,dx   ;cx存放余数，dx高位，ax低位</span><br><span class="line">mov dx,si</span><br><span class="line"></span><br><span class="line">ret</span><br><span class="line">codesg ends  </span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>效果如下<br><img src="/2023/07/20/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%8010-12/10.2.png"><br>3.数值显示，把数据段的数据以十进制显示出来，通过除法转化为十进制，再对照ASCII码表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">db 10 dup (0)</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:  </span><br><span class="line">    mov ax,12666    ;作为例子的数据</span><br><span class="line">mov bx,data         ;存放处理后数据的空间</span><br><span class="line">mov ds,bx</span><br><span class="line">mov si,0</span><br><span class="line">call dtoc           ;转化为十进制</span><br><span class="line"></span><br><span class="line">mov dh,8            ;显示的位置和样式</span><br><span class="line">mov dl,3</span><br><span class="line">mov cl,2</span><br><span class="line">call show_str</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">dtoc:                   </span><br><span class="line">    push ax             ;在开始转化前的压栈</span><br><span class="line">push bx</span><br><span class="line">push si</span><br><span class="line">push di</span><br><span class="line">mov di,0</span><br><span class="line">mov bx,10</span><br><span class="line"></span><br><span class="line">ahhhh:  </span><br><span class="line">    mov dx,0</span><br><span class="line">div bx</span><br><span class="line">add dx,30h</span><br><span class="line">push dx</span><br><span class="line">mov cx,ax</span><br><span class="line">inc di</span><br><span class="line">jcxz okk</span><br><span class="line">jmp short ahhhh</span><br><span class="line"></span><br><span class="line">okk:    </span><br><span class="line">    mov cx,di</span><br><span class="line">okkk:</span><br><span class="line">    pop ax</span><br><span class="line">mov [si],al</span><br><span class="line">inc si</span><br><span class="line">loop okkk</span><br><span class="line">pop di</span><br><span class="line">pop si</span><br><span class="line">pop bx</span><br><span class="line">pop ax</span><br><span class="line">ret                    ;dotc结束</span><br><span class="line"></span><br><span class="line">show_str:</span><br><span class="line">push ax</span><br><span class="line">push bx</span><br><span class="line">push cx</span><br><span class="line">push dx</span><br><span class="line">push es</span><br><span class="line">push si</span><br><span class="line">push di</span><br><span class="line"></span><br><span class="line">mov ax,0b800h</span><br><span class="line">mov es,ax</span><br><span class="line"></span><br><span class="line">mov al,160</span><br><span class="line">mul dh</span><br><span class="line">mov bx,ax</span><br><span class="line">mov al,2</span><br><span class="line">mul dl</span><br><span class="line">add bx,ax</span><br><span class="line"></span><br><span class="line">mov al,cl</span><br><span class="line">mov ch,0</span><br><span class="line">mov di,0</span><br><span class="line"></span><br><span class="line">showc:  </span><br><span class="line">    mov cl,ds:[si]          ;循环来逐字移动到显示的内存区域</span><br><span class="line">jcxz ok</span><br><span class="line">mov es:[bx+di],cl</span><br><span class="line">mov es:[bx+di+1],al</span><br><span class="line">inc si</span><br><span class="line">add di,2</span><br><span class="line">jmp short showc</span><br><span class="line"></span><br><span class="line">ok:    </span><br><span class="line">    pop di</span><br><span class="line">pop si</span><br><span class="line">pop es</span><br><span class="line">pop dx</span><br><span class="line">pop cx</span><br><span class="line">pop bx</span><br><span class="line">pop ax</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>效果图如下,显示区貌似是直接覆盖的所以多刷了一些回车变成空白页好看一点<br><img src="/2023/07/20/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%8010-12/10.3.png"><br>课程设计1的内容主要参考的网上的代码，在自己写的时候反而不停的发现实验七的代码有问题，所以干脆换成了网上看见的另一个结构或者说思路的数据整理顺序，这里就不贴了。</p><h2 id="第11章"><a href="#第11章" class="headerlink" title="第11章"></a>第11章</h2><h3 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h3><p>标志寄存器用于储存某些指令的执行结果，控制CPU的相关工作方式，按位起作用比如8086CPU的flag寄存器从0到15位中，1，3，5，12，13，14，15均没有作用其他有内容的标志位分别是cf，pf，af，zf，sf，df，of，在debug中有体现<br>zf，零标志位，执行相关指令后结果为0则该标志位内容为1.debug中zr为1，nz为0.<br>pf，奇偶标志位，执行后储存结果的寄存器bit位中1的个数位偶数则为1.debug中pe为1，po为0.<br>sf，符号标志位，执行后结果为负则为1.debug中ng为1，pl为0.<br>cf，进位符号位，无符号运算时向更高位进位或者借位的值则为1.debug中cy为1，nc为0.<br>of，溢出标志位，有符号运算时超出机器表达范围就将产生溢出。debug中ov为1，nv为0.<br>df，方向标志位，控制每次操作后si，di的增减，减少则为1.debug中dn为1，up为0.<br><img src="/2023/07/20/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%8010-12/0.1.png"></p><h3 id="相关指令"><a href="#相关指令" class="headerlink" title="相关指令"></a>相关指令</h3><p>adc是带进位的加法指令，比如 adc ax，3也就是ax&#x3D;ax+3+cf。<br>sbb是带借位减法指令，比如sbb ax，bx 也就是ax&#x3D;ax-bx-cf。<br>cmp是比较指令，相当于减法，不保留结果，只影响标志寄存器的内容<br>转移指令，je（等于则转移，zf&#x3D;1）；jne（不等于，zf&#x3D;0）；jb（低于，cf&#x3D;1）；jnb（不低于，cf&#x3D;0）；ja（高于，cf&#x3D;0且zf&#x3D;0）；jna（不高于，cf&#x3D;1或zf&#x3D;1）.<br>movsb串传送命令，操作为把ds偏移si的内容给es偏移di，而后根据df的值来让si和di减小1或增加1.movsw则为增加或减少2.而同时cld可以将df设置为0，std则为1.<br>rep指令会根据cx的值重复执行后面的串传送指令，可以将rep和movsb一起用来转移或者说复制代码到另一个地方，类rep movsb。<br>pushf将标志寄存器内容压栈，poopf将标志寄存器内容出栈。</p><h3 id="实验11"><a href="#实验11" class="headerlink" title="实验11"></a>实验11</h3><p>把以0结尾的字符串中的小写字母转变为大写字母。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">datasg segment</span><br><span class="line">db &quot;Beginner&#x27;s All-purpose Symbolic Instruction Code.&quot;,0</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:  mov ax,datasg</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,0</span><br><span class="line">call letterc</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">letterc:push cx</span><br><span class="line">mov ch,0</span><br><span class="line"></span><br><span class="line">  s:    mov cl,[si] </span><br><span class="line">jcxz okk</span><br><span class="line"></span><br><span class="line">cmp cl,97    ;97和122为小写字母的范围，如果不在范围则跳转inc si进入下一个字母的循环</span><br><span class="line">jb ok</span><br><span class="line">cmp cl,122</span><br><span class="line">ja ok</span><br><span class="line"></span><br><span class="line">and cl,11011111b</span><br><span class="line">mov [si],cl</span><br><span class="line"></span><br><span class="line">  ok:   inc si</span><br><span class="line">jmp short s</span><br><span class="line">  </span><br><span class="line">  okk:  pop cx</span><br><span class="line">ret</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p><img src="/2023/07/20/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%8010-12/11.1.png"></p><h2 id="第12章"><a href="#第12章" class="headerlink" title="第12章"></a>第12章</h2><h3 id="内中断的产生和处理"><a href="#内中断的产生和处理" class="headerlink" title="内中断的产生和处理"></a>内中断的产生和处理</h3><p>中断也就是CPU在接收到信号后立即对该信号后不继续执行正在执行的程序，转而多信号进行处理，而这个信号被称为中断信息。<br>内中断的中断源有以下四种：除法错误（溢出等），单步执行，执行into指令，执行interesting指令。中断源发出的中断信息中必须包含识别来源的编码，终端类型码为一个字节型数据，可以表示256种中断信息的来源。而根据这个码在内存中的中断向量表找到对应的中断向量，进而通过中断向量前往中断处理程序。对于8086pc机而言中断向量表指定存放在内存地址为0的位置从0000：0000到0000：03FF的1024个单元中存放着中断向量表，但事实上没有这么多的中断向量，部分内存是闲置的。<br>在处理内中断信息时考虑到需要返回继续执行未执行完的代码，所以会在进入处理程序前先保存原本的cs和ip，保存处理程序需要使用的寄存器的值等再处理。完整过程为获得中断码-&gt;标志内存器入栈-&gt;将标志内存器的第8.9位的TF和IF设置为0-&gt;cs，ip先后入栈-&gt;从内存地址为中断类型码<em>4和中断类型码</em>4+2的内存地址读取中断处理程序的入口的ip和cs（<em>4和</em>4+2是因为每个类型都需要两个低位字节存ip两个高位存cs，且完全按照中断码编号分配内存）-&gt;保存用到的寄存器，处理中断，恢复寄存器，iret指令（相当于pop ip，pop cs，popf）返回</p><h3 id="中断处理实例"><a href="#中断处理实例" class="headerlink" title="中断处理实例"></a>中断处理实例</h3><p>除法错误比如溢出时会显示divide overflow作为提醒，显示后返回操作系统中，debug时也就是直接退出debug。<br>单步中断，就好像debug的t命令，再执行t命令时debug会将TF设置为1，再CPU执行完该指令后引发单步中断，再将tf置为0，再执行中断处理程序，所有寄存器内容会被显示在屏幕上。这个时候再回过头看一下在一般执行中断程序前的tf&#x3D;0的步骤有了解释。<br>在响应中断处理时需要注意如果正在设置ss的数据而未设置sp将无法进行中断，因为在中断程序中需要往栈内压入内容但是如果仅设置ss，无法指向一个正确的栈顶。所以在设置ss和sp时需要紧接着设置不然无法中断。回看实验二的内容，为什么那一条指令（mov sp,10）没有显示执行过程。正是因为无法中断。<br><img src="/2023/07/20/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%8010-12/2.1.png"><br>###实验12<br>编写0号中断的处理程序，不知道要怎么调试所以看网上的往里面塞了一段溢出的代码作为调试得到的效果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">    mov ax,cs                       ;以下到call之前都是安装部分</span><br><span class="line">mov ds,ax                       ;这里是将0号的中断处理程序复制到0：200h处</span><br><span class="line">mov si,offset do0</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,200h</span><br><span class="line">mov cx,offset do0end-offset do0 ;直接通过减法得到程序的大小</span><br><span class="line">cld                             ;设置传输方向为正</span><br><span class="line">rep movsb                       </span><br><span class="line"></span><br><span class="line">mov ax,0                        ;将0号中断向量更改为指向本程序编写的地址</span><br><span class="line">mov es,ax</span><br><span class="line">mov word ptr es:[0*4],200h</span><br><span class="line">mov word ptr es:[0*4+2],0</span><br><span class="line"></span><br><span class="line">call mytest</span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line">    mov ax,4c00H</span><br><span class="line">    int 21H</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  do0:  jmp short do0start          ;相当于被打包的行李，通过前面的安装程序放到了内存中</span><br><span class="line">db &quot;divide error!&quot;              ;作为数据不好放在其他地方会被覆盖，所以一起打包了，但是没法执行所以前面jmp掉了</span><br><span class="line"></span><br><span class="line">do0start:</span><br><span class="line">    push ax                         ;在中断处理程序也需要保存备份</span><br><span class="line">    push es</span><br><span class="line">    push di</span><br><span class="line">    push ds</span><br><span class="line">    push si</span><br><span class="line">    push cx</span><br><span class="line"></span><br><span class="line">    mov ax,cs                       ;找到需要输出的字符的位置</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,202h</span><br><span class="line"></span><br><span class="line">mov ax,0b800h                   ;显示出来的步骤</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,12*160+36*2</span><br><span class="line"></span><br><span class="line">mov cx,13</span><br><span class="line"></span><br><span class="line">  s:</span><br><span class="line">    mov al,[si]</span><br><span class="line">mov es:[di],al</span><br><span class="line">inc si</span><br><span class="line">add di,2</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">    pop cx</span><br><span class="line">    pop si</span><br><span class="line">    pop ds</span><br><span class="line">    pop di</span><br><span class="line">    pop es</span><br><span class="line">    pop ax</span><br><span class="line"></span><br><span class="line">mov ax,4c00h                    ;作为一个完整的程序需要结束语</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">mytest:          ;调试程序</span><br><span class="line">    push ax</span><br><span class="line">    push bx</span><br><span class="line"> </span><br><span class="line">    mov ax,1000H    </span><br><span class="line">    mov bl,1H </span><br><span class="line">    div bl      ;产生除法溢出，触发0号中断</span><br><span class="line"> </span><br><span class="line">    pop bx</span><br><span class="line">    pop ax</span><br><span class="line"> </span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">do0end:nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>效果图如下<br><img src="/2023/07/20/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%8010-12/12.1.png"><br>我想起来我可以直接看es的内容，所以把那个调试部分删除了，代码基本没变效果图如下，第一张是未变更状态，第二张是执行后<br><img src="/2023/07/20/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%8010-12/12.3.png"><br><img src="/2023/07/20/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%8010-12/12.2.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;摸鱼的进度确实不太行呢&lt;/p&gt;</summary>
    
    
    
    <category term="《汇编语言》自学之路" scheme="http://librariany.cn/categories/%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="汇编" scheme="http://librariany.cn/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言7-9自学回顾</title>
    <link href="http://librariany.cn/2023/07/18/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%807-9/"/>
    <id>http://librariany.cn/2023/07/18/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%807-9/</id>
    <published>2023-07-18T03:10:21.000Z</published>
    <updated>2024-07-13T10:45:54.377Z</updated>
    
    <content type="html"><![CDATA[<p>看见满屏花花绿绿我仿佛看见了我太奶</p><span id="more"></span><h2 id="第7章"><a href="#第7章" class="headerlink" title="第7章"></a>第7章</h2><h3 id="and-amp-or-SI-amp-DI-amp-bp"><a href="#and-amp-or-SI-amp-DI-amp-bp" class="headerlink" title="and &amp; or   SI &amp; DI &amp; bp"></a>and &amp; or   SI &amp; DI &amp; bp</h3><p>and指令进行按位与运算，可通过该指令将操作对象对应位设为0。or指令进行按位或运算，可通过改指令将操作对象对应位设为1。这里的按位均按二进制进行。<br>si，di是8086CPU中和bx功能相近的寄存器，不能作为两个8位寄存器来使用。bp也可以作为偏移地址，但是其默认的段地址在ss中。<br>mov ax,[bx+si+idata]中的括号内容也可以有以下表现形式：[bx+200+si]，[200+bx+si]，200[bx][si]，[bx].200[si]，[bx][si]200。即可以用一个变量；一个常量；一个变量+一个常量；两个变量；两个变量+一个常量</p><h3 id="实验6"><a href="#实验6" class="headerlink" title="实验6"></a>实验6</h3><p>编程使得给出的字符串的前四个字母变成大写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ss:stacksg,ds:datasg</span><br><span class="line"></span><br><span class="line">stacksg segment</span><br><span class="line">dw 0,0,0,0,0,0,0,0</span><br><span class="line">stacksg ends</span><br><span class="line"></span><br><span class="line">datasg segment</span><br><span class="line">db &#x27;1. display      &#x27;</span><br><span class="line">db &#x27;2. brows        &#x27;</span><br><span class="line">db &#x27;3. replace      &#x27;</span><br><span class="line">db &#x27;4. modify       &#x27;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start: mov ax,datasg</span><br><span class="line">mov ds,ax</span><br><span class="line"></span><br><span class="line">mov ax,stacksg</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,16</span><br><span class="line"></span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,4</span><br><span class="line">   </span><br><span class="line">   s:   push cx</span><br><span class="line">mov si,0</span><br><span class="line">mov cx,4</span><br><span class="line"></span><br><span class="line">  s0:   mov al,[bx+si+3]   ;因为每行的第一个字母都在第四个，所以+3</span><br><span class="line">and al,11011111b       ;因为ASCII码表中大写与小写的差距，这一位为1则为小写</span><br><span class="line">mov [bx+si+3],al</span><br><span class="line">inc si</span><br><span class="line">loop s0</span><br><span class="line"></span><br><span class="line">add bx,16</span><br><span class="line">pop cx</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>以下为运行中途的结果展示<br><img src="/2023/07/18/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%807-9/6.1.png"></p><h2 id="第8章"><a href="#第8章" class="headerlink" title="第8章"></a>第8章</h2><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>数据可以在三个位置：CPU内部，内存，端口。而表达数据可以有三种概念：立即数（即包含在机器指令中的数据，执行前在CPU的指令缓冲器中），寄存器，段地址和偏移地址（在内存中）。<br>数据的尺寸可以有两种指明方式，1.通过寄存器指明，类似于mov ax,1为字操作mov al,1为字节操作；2.可以用操作符x ptr完成，类似于mov word ptr[bx],1为一个字单元，mov byte ptr [bx],1为一个字节单元。</p><h3 id="div指令"><a href="#div指令" class="headerlink" title="div指令"></a>div指令</h3><p>div是一个除法指令，除数保存在寄存器或者内存单元中，16位的被除数放ax中而32位ax放低16位dx放高16位。结果，8位则al放商，ah放余数；16位则ax放商，dx放余数。<br>格式类div 内存单元&#x2F;寄存器 或者 div byte ptr ds:[0]</p><h3 id="db-dw-dd-amp-dup"><a href="#db-dw-dd-amp-dup" class="headerlink" title="db dw dd &amp; dup"></a>db dw dd &amp; dup</h3><p>在之前定义栈段的时候用过dw，得到的空间为16个字节，而dw也意为为每个数据申请一字的内存，db是一字节，dd是两个字的内存。<br>dup是一个操作符，与db，dw，dd配合使用，用于数据的重复，也就是定义多少个重复的数。格式为db 重复次数 dup （重复的字节型数据） 格式以此类推。例如需要申请一个容量为200和字节的栈段，db 200 dup(0)。</p><h3 id="实验7"><a href="#实验7" class="headerlink" title="实验7"></a>实验7</h3><p>将已有数据按照一定格式存入空间中，并增加一个位置用于储存计算结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ss:stack</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">db &#x27;1975&#x27;,&#x27;1976&#x27;,&#x27;1977&#x27;,&#x27;1978&#x27;,&#x27;1979&#x27;,&#x27;1980&#x27;,&#x27;1981&#x27;,&#x27;1982&#x27;,&#x27;1983&#x27;</span><br><span class="line">db &#x27;1984&#x27;,&#x27;1985&#x27;,&#x27;1986&#x27;,&#x27;1987&#x27;,&#x27;1988&#x27;,&#x27;1989&#x27;,&#x27;1990&#x27;,&#x27;1991&#x27;,&#x27;1992&#x27;</span><br><span class="line">db &#x27;1993&#x27;,&#x27;1994&#x27;,&#x27;1995&#x27;</span><br><span class="line"></span><br><span class="line">dd 16,22,382,1356,2390,8000,16000,244486,50065,97479,140417,197514</span><br><span class="line">dd 345980,590827,803530,1183000,1843000,2759000,3753000,4649000,5937000</span><br><span class="line"></span><br><span class="line">dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226</span><br><span class="line">dw 11542,14430,15257,17800</span><br><span class="line"></span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">table segment</span><br><span class="line">db 21 dup(&#x27;year sume ne ?? &#x27;)</span><br><span class="line">table ends</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">db 8 dup(0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">starts: mov ax,table</span><br><span class="line">mov ds,ax</span><br><span class="line"></span><br><span class="line">mov ax,data</span><br><span class="line">mov es,ax</span><br><span class="line"></span><br><span class="line">mov bx,0</span><br><span class="line">mov si,0   ;year</span><br><span class="line">mov di,84  ;get</span><br><span class="line">mov bp,168 ;num</span><br><span class="line"></span><br><span class="line">mov cx,21</span><br><span class="line"></span><br><span class="line">    S:  mov ax,es:[si]  ;year</span><br><span class="line">mov [bx],ax</span><br><span class="line">add si,2</span><br><span class="line">mov ax,es:[si]</span><br><span class="line">mov [bx].2,ax</span><br><span class="line">add si,2</span><br><span class="line"></span><br><span class="line">mov ax,es:[di]  ;get</span><br><span class="line">mov [bx].5,ax</span><br><span class="line">add di,2</span><br><span class="line">mov ax,es:[di]</span><br><span class="line">mov [bx].7,ax</span><br><span class="line">add di,2</span><br><span class="line"></span><br><span class="line">mov ax,es:[bp]   ;num</span><br><span class="line">mov [bx].10,ax</span><br><span class="line"></span><br><span class="line">mov ax,[bx+5]</span><br><span class="line">mov dx,[bx+7]</span><br><span class="line">div word ptr [bx+10]</span><br><span class="line">mov [bx+13],ax</span><br><span class="line">add bp,2</span><br><span class="line"></span><br><span class="line">add bx,16</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end starts</span><br></pre></td></tr></table></figure><p>下图为效果展示（关于我到了第十章却反复修改了三次这个代码这件事<br><img src="/2023/07/18/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%807-9/7.1.png"></p><h2 id="第9章"><a href="#第9章" class="headerlink" title="第9章"></a>第9章</h2><h3 id="offset"><a href="#offset" class="headerlink" title="offset"></a>offset</h3><p>修改执行指令的顺寻的指令为转移指令，在8086CPU中转移指令分为：无条件转移指令，条件转移指令，循环指令，过程，中断。转移行为分为了只修改IP的段内转移，修改CS和IP的段间转移。<br>操作符offset可以获得标号的偏移地址，比如，mov ax,offset start，ax中会保存start标识位置的相对偏移地址。</p><h3 id="jmp"><a href="#jmp" class="headerlink" title="jmp"></a>jmp</h3><p>jmp short 标号，段内短转移，对IP的修改范围为-128-127，该指令的机器码中不包含转移的目的地而是偏移地址。<br>jmp far ptr 标号，段间转移。机器码中包含目的地址，高地址为段地址，低地址为偏移地址。<br>jmp 寄存器（16位）IP修改为寄存器的内容。<br>jmp word ptr 内存单元地址（段内转移），单元中存放的是目的偏移地址。<br>jmp dword ptr 内存单元地址（段间转移），高地址是转移的目的段地址，低地址是转移的目的偏移地址。</p><h3 id="jcxz-amp-loop"><a href="#jcxz-amp-loop" class="headerlink" title="jcxz &amp; loop"></a>jcxz &amp; loop</h3><p>jcxz是条件转移地址，所有的有条件转移指令都是段转移，对应机器码中包含转移的位移，而不是目的地址，格式：jcxz 标号。转移条件为cx内容&#x3D;&#x3D;0。<br>loop作为循环指令的基础就是loop能根据标号转移，同时cx&#x3D;&#x3D;0也是loop的条件。<br>ps：如果源程序中出现了转移范围越界的问题，在编译时编译器会报错。</p><h3 id="实验8"><a href="#实验8" class="headerlink" title="实验8"></a>实验8</h3><p>分析一个奇怪的程序，运行来观察其实现过程，乍一看代码是真的匪夷所思。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">mov ax,4c00h  ;估计会跳转到这里完成结束</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">start: </span><br><span class="line">    mov ax,0</span><br><span class="line">s:  nop</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">    mov di,offset s     ;这里用di将s所处IP记录了，0008h</span><br><span class="line">mov si,offset s2    ;这里的si记录了s2的偏移地址，0020h</span><br><span class="line">mov ax,cs:[si]      ;将s2地址的机器码给了ax-F6EB，对应jmp 0018h，向上偏移8个字节</span><br><span class="line">mov cs:[di],ax      ;将s2标识的机器码存入了s标识处</span><br><span class="line"></span><br><span class="line">s0: jmp short s         ;即将跳转到0008，debug-u查看0008为jum 0000，向上偏移8个字节</span><br><span class="line"></span><br><span class="line">s1: mov ax,0</span><br><span class="line">int 21h</span><br><span class="line">mov ax,0</span><br><span class="line"></span><br><span class="line">s2: jmp short s1</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以下是过程截图<br><img src="/2023/07/18/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%807-9/8.1.png"><br><img src="/2023/07/18/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%807-9/8.2.png"><br><img src="/2023/07/18/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%807-9/8.3.png"></p><h3 id="实验9"><a href="#实验9" class="headerlink" title="实验9"></a>实验9</h3><p>在画面中间显示要求的花里胡哨的字符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:data</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">db &#x27;welcome to masm!&#x27;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:  </span><br><span class="line">    mov ax,data</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov ax,0b800h  ;在视频内存的情况下，0xB800 是一个常见的地址，用于文本模式下的屏幕显示。它包含一个特殊的显示缓冲区，用于在屏幕上显示文本和字符。</span><br><span class="line">    mov es,ax</span><br><span class="line">mov di,0</span><br><span class="line">mov si,40h</span><br><span class="line"></span><br><span class="line">mov cx,07h</span><br><span class="line">s1: mov ah,00000111b  ;显示的有颜色的字高位存储的是花式</span><br><span class="line">mov al,[di]       ;低地址存储数据</span><br><span class="line">mov es:[780h+si],ax </span><br><span class="line">inc di</span><br><span class="line">add si,2</span><br><span class="line">loop s1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">inc di       ;这里是空格的位置</span><br><span class="line">add si,2</span><br><span class="line"></span><br><span class="line">mov cx,02h</span><br><span class="line">s2: mov ah,00100100b</span><br><span class="line">mov al,[di]</span><br><span class="line">mov es:[780h+si],ax</span><br><span class="line">inc di</span><br><span class="line">add si,2</span><br><span class="line">loop s2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">inc di</span><br><span class="line">add si,2</span><br><span class="line"></span><br><span class="line">mov cx,05h</span><br><span class="line">s3: mov ah,01110001b</span><br><span class="line">mov al,[di]</span><br><span class="line">mov es:[780h+si],ax</span><br><span class="line">inc di</span><br><span class="line">add si,2</span><br><span class="line">loop s3</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>贴一个效果图<br><img src="/2023/07/18/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%807-9/9.2.png"><br>分享一个我不小心把循环的标识写错了的输出效果图，跟吃了菌子一样<br><img src="/2023/07/18/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%807-9/9.1.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;看见满屏花花绿绿我仿佛看见了我太奶&lt;/p&gt;</summary>
    
    
    
    <category term="《汇编语言》自学之路" scheme="http://librariany.cn/categories/%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="汇编" scheme="http://librariany.cn/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言4-6自学回顾</title>
    <link href="http://librariany.cn/2023/07/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%804-6/"/>
    <id>http://librariany.cn/2023/07/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%804-6/</id>
    <published>2023-07-15T00:43:52.000Z</published>
    <updated>2024-07-13T10:45:54.374Z</updated>
    
    <content type="html"><![CDATA[<p>尝试写程序啦</p><span id="more"></span><h2 id="第4章"><a href="#第4章" class="headerlink" title="第4章"></a>第4章</h2><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>需要用到的工具为文本编译器（如记事本，edit），汇编语言编译程序（进行编译，连接），执行已完成程序的工具程序。在文本程序中写出来的部分成为源程序文件，经过编译器则为可执行文件，也就是从asm到exe。<br>而由于edit和debug等在win11上被取消了，所以安装了dosbox，把相应的工具放在了和代码一个文件夹里。至于ms-dos的相应安装以及配置过程过于繁琐，个人比较推荐dosbox。</p><h3 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h3><p>源程序文件中的所有内容被称为源程序，源程序之所以需要经过编译器才能执行原因有二，一为需要将程序翻译为机器码，二是源程序由汇编指令和伪指令组成，机器不会运行伪指令，而是编译器会运行。源程序执行后成为程序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">       mov ax,0123h</span><br><span class="line">       mov bx,0456h</span><br><span class="line">       add ax,bx</span><br><span class="line"></span><br><span class="line">       mov ax,4c00h</span><br><span class="line">       int 21h</span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>其中<code>assume cs:codesg</code>，<code>codesg segment···codesg ends</code>，<code>end</code>是伪代码，有着不同的功能。<br><code>assume</code>含义为假设，在计算机中所有的内存是连续的，但是在cpu执行时内存被划分为了许多的段，用来存储不同作用的数据。而这里的假设就是假设内存中某个段和源程序中某个段相关联。这个示例中则是让codesg与cs寄存器相联系。<br><code>codesg segment ··· codesg ends</code>这是俩称多使用的伪指令，用于定义一个段，可以是代码，数据，栈等用处的段。codesg则为改段的名称，名称在被编译连接程序处理后作为一个段的地址。segment时开始的标志，ends是段结尾的标志。一个有意义的汇编程序，至少需要一个段。<br><code>end</code>作为程序结束的标志，在编译器编译到end时会停止编译。<br>在汇编源程序中，数据不能以字母开头，比如A000h要写作0A000h。</p><h3 id="编译-连接-执行"><a href="#编译-连接-执行" class="headerlink" title="编译 连接 执行"></a>编译 连接 执行</h3><p>在写好源程序之后会得到一个以asm为后缀的文件，对这个文件进行编译，我使用的时masm配置到dosbox里面的在界面内输入<code>masm 名称.asm</code>如果文件不在所显示的路径中要补充路径。在这之后会有三个回车的确认，第一个是确认asm的文件名，第二个是确认后续连接使用的obj后缀的文件名，第三个是生成的列表文件，第三个回车其实是确认不生成这个中间文件。在这里会有报错提醒，具体定位到源程序文件的行。<br>连接使用的是link，连接会生成可执行文档，同时也会在这一步将包含子函数的库函数该程序进行连接，方便调用。连接的操作则是<code>link 名称.obj</code>，第一个确认是输入的文件名（我的link或许是版本问题，没有这一步），第二个是输出的exe文件名，第三个映像文件（将一系列文件做成单一格式方便下载的文件）同样是中间结果，可以不输出，第四个是连接库函数（我的例子中不需要库函数所以为空），此处的warning不影响后续使用，具体原因学会了补充。<br><img src="/2023/07/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%804-6/0.1.png"><br>执行时需要有一个程序来让我们的程序执行，也就是可执行文件在加载后需要一个程序将CPU的控制权交给该文件，才能让文件得到执行，并且在执行后将CPU的控制权交还，结束执行。而这个交还控制权的操作叫做程序返回。<br>程序返回的实现靠的是源程序中的两条指令。<code>mov ax,4c00h  int 21h</code>，在上面的代码的例子中，这两条指令没有在程序对数据的处理中起作用，他们的作用就体现在了程序返回上。在dos系统上这个让可执行文件执行的文件即为command.com，command根据文件名找到可执行文件后将文件中的程序加载入内存，设置CS:IP指向该程序的入口，随后CPU开始运行该程序，程序结束后又返回command。debug也是由command载入，并在调试结束后返回command。<br>加载程序时会将程序载入一个连续的段内，但是程序的代码与段首有256个字节的距离，这段距离被称为PSP区，主要作用是让dos和被加载系统通讯。</p><h3 id="实验3"><a href="#实验3" class="headerlink" title="实验3"></a>实验3</h3><p>用debug跟进一个程序，查看寄存器内容，栈顶的内容，以及PSP的内容。<br>指令一览<br><img src="/2023/07/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%804-6/3.0.png"><br>查看ds的存储内容可以发现在代码储存空间的段首是以CD 20开头的PSP<br><img src="/2023/07/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%804-6/3.4.png"><br>此处因为<code>mov sp,10</code>，所以sp值改变<br><img src="/2023/07/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%804-6/3.1.png"><br>因为ax，bx值均为0所以ss:sp指向的区域一致在增减00。<br><img src="/2023/07/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%804-6/3.2.png"><br>在<code>int 21h</code>即将执行时需要用p指令来结束程序<br><img src="/2023/07/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%804-6/3.3.png"></p><h2 id="第5章"><a href="#第5章" class="headerlink" title="第5章"></a>第5章</h2><h3 id="bx-amp-段前缀"><a href="#bx-amp-段前缀" class="headerlink" title="[bx] &amp; 段前缀"></a>[bx] &amp; 段前缀</h3><p>[bx]类似于[0]，表示偏移地址，段地址默认为ds。<br>在masm中[1]会被直接作为1，而在debug中会作为[1]进行执行，所以为了在汇编源程序中达到偏移地址的效果，只能用[bx]作为中转，例如 <code>mov ax,[1]</code>需变更为<code>mov bx,1 ；mov ax,[bx]</code>或者标注段寄存器<code>mov ax,ds:[1]</code>。<br>类似于<code>mov ax,ds:[1]</code>的写法还可以拓展到各个访问内存单元的段地址中，ds，cs，ss，es等，类似于<code>mov ax,ss:[bx]</code>这种写法称之为段前缀。<br>需要注意的是有些空间是dos在使用，占用这些空间会造成死机等后果，而dos和其他合法程序一般不会使用0:200-0:2ff的256个字节空间，较为安全，可以用debug查询存储内容以确认安全性。</p><h3 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h3><p>loop的作用可以理解为控制循环，进行的操作有两步：cx&#x3D;cx-1 -&gt; 判断cx值是否为零，否在跳转回标记处，是则退出循环。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">    mov ax,2</span><br><span class="line">    mov cx,11</span><br><span class="line"></span><br><span class="line"> s: add ax,ax</span><br><span class="line">    loop s</span><br><span class="line"></span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>这段代码中的s即为loop指令的标记，cx表示循环执行次数为11次。<br>在debug中可以用p命令将循环一次执行完，用g 加偏移地址可以直接从此处执行到指定地址，类g 0012h。</p><h3 id="实验4"><a href="#实验4" class="headerlink" title="实验4"></a>实验4</h3><p>主要是[bx]以及loop的运用。<br>以下是向内存0:200-0:23F一次传送数据0-63(3fh)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">    mov bx,0020h</span><br><span class="line">    mov ds,bx</span><br><span class="line">    mov ax,0h</span><br><span class="line">    mov cx,64</span><br><span class="line"></span><br><span class="line"> s: mov [ax],al      //用al是因为这里的地址要求按字节传送数据，ax会覆盖 </span><br><span class="line">    inc al</span><br><span class="line">    loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>以下是将<code>mov ax,4cooh</code>之前的指令复制到内存0:200处。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">    mov ax,cs        //cs是代码的起点</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov ax,0020h    </span><br><span class="line">    mov es,ax</span><br><span class="line">    mov bx,0</span><br><span class="line">    mov cx,17h      //这里的17h是在试验后得出的</span><br><span class="line"></span><br><span class="line"> s: mov al,[bx]      </span><br><span class="line">    mov es:[bx],al  </span><br><span class="line">    inc bx</span><br><span class="line">    loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>debubg可以查看到这个代码的全场为cx的初始值，用u可以看到最后两行也就是int 21h那两行的地址，由此可以得到需要复制的代码的长度，则为17h。如下图<br><img src="/2023/07/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%804-6/4.1.png"></p><h2 id="第6章"><a href="#第6章" class="headerlink" title="第6章"></a>第6章</h2><h3 id="定义不同段"><a href="#定义不同段" class="headerlink" title="定义不同段"></a>定义不同段</h3><p>需要用到数据时我们需要在汇编源文件定义这些数据，经过编译，连接后作为程序的一部分写到可执行文件中，这样在程序被载入内存时，数据也获得了存储空间。可以在代码段中定义，比如在用<code>dw 0123h,0456h</code>，dw的意思是定义字型数据。同时也可以在代码段外定义一个新的段，同样用segment标识，还需要在assume标出。<br>也可以定义栈，类<code>dw 0,0,0一共16个0</code>，定义后将获得16个字型数据的空间，在程序中设置ss和sp就可以作为栈来使用。<br>在设置了其他段的情况下，执行代码需要将IP调偏移地址到代码所在，或者用start作为标志。并且在end处标明,end除了通知编译器程序结束以外还可以通知编译器程序的入口在哪里。在编译，连接以后由end start指明的程序入口被转化为一个入口地址，存储在可执行文件的描述信息里面。引用段的地址需要先将地址放入寄存器再mov。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data,ss:stack</span><br><span class="line">.....</span><br><span class="line">code segment</span><br><span class="line">    dw...</span><br><span class="line">start:</span><br><span class="line">.....</span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">emd start</span><br></pre></td></tr></table></figure><h3 id="实验5"><a href="#实验5" class="headerlink" title="实验5"></a>实验5</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data,ss:stack</span><br><span class="line">data segment</span><br><span class="line">    dw 0123h,0456h,0789h,0abch,0defh,0cbah,0987h</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">    dw 0,0,0,0,0,0,0,0</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">starts: mov ax,stack</span><br><span class="line">        mov ss,ax</span><br><span class="line">        mov sp,16</span><br><span class="line"></span><br><span class="line">        mov ax,data</span><br><span class="line">        mov ds,ax</span><br><span class="line"></span><br><span class="line">        push ds:[0]</span><br><span class="line">        push ds:[2]</span><br><span class="line">        pop ds:[2]</span><br><span class="line">        pop ds:[0]</span><br><span class="line"></span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end starts</span><br></pre></td></tr></table></figure><p>确定以CD 20开头的PSP的位置,在100h的偏移以后就是data了<br><img src="/2023/07/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%804-6/5.1.png"><br>栈的定义，不仅需要先占据内存，还要在程序中赋值SS，SP<br><img src="/2023/07/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%804-6/5.2.png"><br><img src="/2023/07/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%804-6/5.3.png"><br>pop和push改变栈内容实录<br><img src="/2023/07/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%804-6/5.4.png"><br>程序返回前ss，cs，ds的内容<br><img src="/2023/07/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%804-6/5.5.png"><br>下一个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data,ss:stack</span><br><span class="line"> </span><br><span class="line">data segment</span><br><span class="line">    dw 0123h,0456h</span><br><span class="line">data ends</span><br><span class="line"> </span><br><span class="line">stack segment</span><br><span class="line">    dw 0,0</span><br><span class="line">stack ends</span><br><span class="line"> </span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">    mov ax,stack      </span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov sp,16         </span><br><span class="line"> </span><br><span class="line">    mov ax,data       </span><br><span class="line">    mov ds,ax</span><br><span class="line"> </span><br><span class="line">    push ds:[0]</span><br><span class="line">    push ds:[2]</span><br><span class="line">    pop ds:[2]</span><br><span class="line">    pop ds:[0]</span><br><span class="line"> </span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>这里的data只给了俩，但是分配内存仍然是16位<br><img src="/2023/07/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%804-6/5.6.png"><br>下一个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">a segment</span><br><span class="line">    db 1,2,3,4,5,6,7,8</span><br><span class="line">a ends</span><br><span class="line"> </span><br><span class="line">b segment</span><br><span class="line">    db 1,2,3,4,5,6,7,8</span><br><span class="line">b ends</span><br><span class="line"> </span><br><span class="line">c segment</span><br><span class="line">    db 0,0,0,0,0,0,0,0</span><br><span class="line">c ends</span><br><span class="line"> </span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">    mov ax,a</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov ax,c</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov bx,0</span><br><span class="line">    mov cx,8</span><br><span class="line"></span><br><span class="line">s1: mov ax,es:[bx]</span><br><span class="line">    mov [bx],ax </span><br><span class="line">    add bx,2</span><br><span class="line">    loop s1</span><br><span class="line"></span><br><span class="line">    mov ax,b</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov bx,0</span><br><span class="line">    mov cx,8</span><br><span class="line"></span><br><span class="line">s2: mov ax,es:[bx]</span><br><span class="line">    add [bx],ax</span><br><span class="line">    add bx,2</span><br><span class="line">    loop s2    </span><br><span class="line"></span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>这里经过了三次循环，主要是为了将a，b段的诗句加在一起保存到c段，有够繁琐的这题，如下图标的就是最后的内容，确实是相加成功了<br><img src="/2023/07/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%804-6/5.7.png"><br>下一个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">a segment</span><br><span class="line"></span><br><span class="line">    dw 1,2,3,4,5,6,7,8</span><br><span class="line"></span><br><span class="line">a ends</span><br><span class="line"></span><br><span class="line">b segment</span><br><span class="line"></span><br><span class="line">    dw 0,0,0,0,0,0,0,0</span><br><span class="line"></span><br><span class="line">b ends</span><br><span class="line"> </span><br><span class="line">code segment</span><br><span class="line"> </span><br><span class="line">start:  mov ax,b</span><br><span class="line">        mov ss,ax</span><br><span class="line">        mov sp,16</span><br><span class="line">mov ax,a</span><br><span class="line">mov ds,ax</span><br><span class="line">mov ax,0</span><br><span class="line">mov cx,8</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">     s: push [bx]  .这里只能用bx，不能用ax</span><br><span class="line">        add bx,2</span><br><span class="line">loop s</span><br><span class="line">    </span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"> </span><br><span class="line">code ends</span><br><span class="line"> </span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>这里用栈的方法做一个逆序，原数据没变，定义的栈是倒序后的结果，定义的段在内存的顺序也是按照定义的顺序来的，偏移的地址也可以按定义顺序计算。<br><img src="/2023/07/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%804-6/5.8.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;尝试写程序啦&lt;/p&gt;</summary>
    
    
    
    <category term="《汇编语言》自学之路" scheme="http://librariany.cn/categories/%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="汇编" scheme="http://librariany.cn/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言1-3自学回顾</title>
    <link href="http://librariany.cn/2023/07/13/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%801-3/"/>
    <id>http://librariany.cn/2023/07/13/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%801-3/</id>
    <published>2023-07-13T09:07:22.000Z</published>
    <updated>2024-07-13T10:45:54.368Z</updated>
    
    <content type="html"><![CDATA[<p>   汇编语言（第四版）1-3章自学的知识点小结</p><span id="more"></span><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="CPU-amp-总线-amp-存储器"><a href="#CPU-amp-总线-amp-存储器" class="headerlink" title="CPU &amp; 总线 &amp;存储器"></a>CPU &amp; 总线 &amp;存储器</h3><p>CPU作为计算机的核心部件，控制整个计算机的运作并进行运算，运算所需的指令和数据储存在存储器中。而存储器被划分为若干个存储单元，每个存储单元从0开始编号，微型存储器的存储单元为一个字节，即八个二进制位。<br>CPU通过接口板控制外部设备，类似于音响等。<br>CPU读取存储单元地址，命令，数据都需要通过总线完成。总线是一根根导线的集合，从逻辑上分为地址总线，控制总线和数据总线。8根数据总线可以传递一个二进制数据。地址总线的宽度决定了CPU的寻址能力，数据总线，控制总线以此类推。<br>例如，1个CPU的寻址能力为8KB，那么它的地址总线宽度为2^13（也就是13根）。<br>存储器从读写属性上分为随机存储器（RAM）和只读存储器（ROM）。<br>随机存储器可读可写，但带电储存，只读存储器只读不写。<br>CPU在控制存储器时均将其作为内存看待，将其总的看作一个由储存单元构成的逻辑存储器，这个逻辑存储器也就是内存地址空间，每个物理存储器在其中占有一个地址段。</p><h2 id="第二章-寄存器"><a href="#第二章-寄存器" class="headerlink" title="第二章 寄存器"></a>第二章 寄存器</h2><h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><p>一个典型的CPU由运算器，控制器，寄存器等期间构成，由总线连接。<br>8086CPU的所有寄存器都是16位，可以放两个字节，AX，BX，CX，DX存放一般性数据，被称为通用寄存器。<br>以AX为例，AX可以分为两个八位寄存器AH+AL，其中AL为低八位，AH为高八位（字一般由两个字节构成，前半为高八位）。<br>在汇编指令中寄存器名称不分大小写。在汇编指令中可以单独改写AH或者AL的值。</p><h3 id="物理地址-amp-段"><a href="#物理地址-amp-段" class="headerlink" title="物理地址 &amp; 段"></a>物理地址 &amp; 段</h3><p>每个内存单元都有唯一的地址，这个唯一的地址被称为物理地址。8086是16位结构的CPU，但是有20位地址总线，所以8086CPU采用内部结合的方式用两个16位地址合成的方法形成一个20位的物理地址。<br>CPU提供两个16位的地址，一个位段地址，一个位偏移地址，输送进地址加法器。物理地址&#x3D;段地址*16+偏移地址。（计算方法也被称为左移四位，四位是基于数据的存储形式为二进制）（可以类比C语言的指针偏移，或者说C语言的指针偏移基于此）<br>段地址，其段并不是内存分段，而是由CPU划分，段地址是连续的内存单元，一个段的起始地址一定是16的倍数，其最大长度为64KB。例如给定段地址1000H,CPU的偏移地址寻址范围为10000H~1FFFFH。<br>段寄存器存放段地址，8086CPU有四个段寄存器：CS，DS，SS，ES。段寄存器无法直接导入数据，需要通过其他寄存器的中转达成。</p><h3 id="CS-amp-IP"><a href="#CS-amp-IP" class="headerlink" title="CS &amp; IP"></a>CS &amp; IP</h3><p>CS和IP指定了当前CPU要读取命令的地址，CS为代码段寄存器，IP为指令指针寄存器。执行的指令为CS的内容*16+IP的内容（IP也可以理解为读取指令时的偏移值）。<br>命令执行的过程为：读取地址-&gt;地址加法器-&gt;读取指令进入指令缓冲区-&gt;IP值自动增加（读取指令长度为多少IP增加多少）-&gt;执行。<br>8086CPU刚开始工作时CS和IP被设置为CS&#x3D;FFFFH，IP&#x3D;0000H。<br>mov指令不能修改CS,IP的值，可以使用jmp指令进行修改，即：1）jmp 段地址:偏移地址 2）jmp 某一合法寄存器（用寄存器中的值修改IP）。<br>当我们需要将一组内存定义为一个代码段时，要将CS:IP指向所定义的代码段的第一条指令的首地址。</p><h3 id="实验1"><a href="#实验1" class="headerlink" title="实验1"></a>实验1</h3><p>因为win11不支持debug所以需要我安装一个MS-DOS的虚拟机进行实验。<br>Debug的功能R（查看，改变CPU寄存器内容），D（查看内存内容），E（改写内存内容），U（机器指令翻译为汇编指令），T（执行一条机器指令），A（以汇编指令格式在内存写入一条机器指令）等。<br>下图为r，d演示（d的格式为：d 段地址:起始偏移地址 中止地址）<br><img src="/2023/07/13/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%801-3/1.1.png" alt="图片"><br>下图为u演示<br><img src="/2023/07/13/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%801-3/1.2.png" alt="图片"><br>下图为a，t演示<br><img src="/2023/07/13/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%801-3/1.3.png" alt="图片"><br><img src="/2023/07/13/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%801-3/1.4.png" alt="图片"></p><h2 id="第三章-寄存器（内存访问）"><a href="#第三章-寄存器（内存访问）" class="headerlink" title="第三章 寄存器（内存访问）"></a>第三章 寄存器（内存访问）</h2><h3 id="字"><a href="#字" class="headerlink" title="字"></a>字</h3><p>16位寄存器来存储一个字，高八位放高字节，低八位低字节遂需要两个连续地址，这两个连续地址构成的内存单元也称为字单元。某一地址的字单元存放的字节型数据为该地址及下一地址构成的连续地址的数据。<br>16根数据线可以一次性传输16位数据，字节型数据的传送可以在mov指令中给出一个16位的寄存器。也可以给一个8位的寄存器，改变某一地址，改变某一个字的高字节或低字节。<br>下图给出改变ax低字节的示例<br><img src="/2023/07/13/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%801-3/0.1.png" alt="图片"></p><h3 id="mov-amp-add-amp-sub"><a href="#mov-amp-add-amp-sub" class="headerlink" title="mov &amp; add &amp; sub"></a>mov &amp; add &amp; sub</h3><p>mov，可以理解为复制粘贴数据到存储空间，mov ax，bx即为复制bx粘贴到ax。<br>add，为加法，add ax，bx即为把bx的值加到ax上。<br>sub，为减法，sub ax，bx即为在ax上减去bx。<br>mov可以直接将数据放入寄存器，也可以让各个寄存器，内存单元互相放数据，但是不能将数据直接放入段寄存器。mov ax,[0]这个0默认为相对于ds寄存器的偏移地址。</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈是一种规划了长度的有特殊访问方式的存储空间，将一段内存定义为一个段作为栈段，其具有先进后出的特殊模式。栈的操作以字为单位，需要借助SS段寄存器和SP寄存器来完成，SS存放栈顶的段地址(最小地址)，SP存放偏移地址。以此来达到指向栈内有元素的最高位的效果。同样地址计算为SS*16+SP。<br>栈最基本的两个指令为出栈pop和入栈push，两个命令后面可以接寄存器，段寄存器或者内存单元(也就是类 pop [0])，push ax：SP&#x3D;SP-2 -&gt; 将ax内容存入此时SS:SP指向的内存单元，pop ax：将SS:SP指向的内容存入ax -&gt; SP&#x3D;SP+2。<br>在进行操作时，被pop或者push的地址总是SS:SP所指向的地址，所以pop和push对SP的改变先后不同，且是自动改变SP内容。同时由于只修改SP，所以栈顶的最大变化范围为0——FFFFH。<br>pop出栈其实也是一个类似于mov的效果，pop被出栈的地址的数据不会改变，之后在下一次该地址被push时被覆盖。<br>假设栈的空间为10000H——1000FH，空栈时SS:SP会指向栈空间最高地址的下一个单元，即10010H，SS为1000H，SP为0010H。栈满是指向空间的最低地址，即10000H，SP为0000H。<br>由于push和pop只是起到一个地址索引没有对地址惊醒一个限制，所以会导致栈顶超界的问题。比如当SS:SP已经指向栈的最大容量后继续push，就会导致栈规划段以外的地址的数据被覆盖，或者当SS:SP指向的数据已经是空栈状态，继续pop就会pop出其他非栈内数据。</p><h3 id="实验2"><a href="#实验2" class="headerlink" title="实验2"></a>实验2</h3><p>中断机制，即在执行完当前任务后，可以检测到CPU中或外部的某种特殊信息，并立刻对此信息进行处理。<br>以下在debug中演示跳过显示修改SP的命令的过程（中断源是单步执行）。<br><img src="/2023/07/13/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%801-3/2.1.png"><br><img src="/2023/07/13/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%801-3/2.2.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;   汇编语言（第四版）1-3章自学的知识点小结&lt;/p&gt;</summary>
    
    
    
    <category term="《汇编语言》自学之路" scheme="http://librariany.cn/categories/%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="汇编" scheme="http://librariany.cn/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>close &amp; begin</title>
    <link href="http://librariany.cn/2023/07/12/begin/"/>
    <id>http://librariany.cn/2023/07/12/begin/</id>
    <published>2023-07-12T11:19:56.000Z</published>
    <updated>2024-07-13T10:45:54.267Z</updated>
    
    <content type="html"><![CDATA[<pre><code>关于终于开始用这个早就配置的差不多的博客，结果搞崩又重新配置这件事。</code></pre><span id="more"></span><h2 id="一点碎碎念"><a href="#一点碎碎念" class="headerlink" title="一点碎碎念"></a>一点碎碎念</h2><p>这个博客的搭建其实还蛮讨巧的，没有去弄服务器那些东西，整体的步骤还是比较简单但是还是在三月份花费了我好几天的时间，一个是因为三月份在上课时间本来就不多还有一个原因就是我太菜了。对，没错，我三月份就搭好了这个博客但是现在七月份我才开始写我的第一篇。一开始想着随便写点什么吧，但是又担心自己的技术根本不到呢个够写文章的地步，但是又想到了或许我写文章其实也只是写写自己会些啥，毕竟所有我这一秒学会的东西对于上一秒的我而言都不是件简单事。本来想着要不要段首空两格，好像没什么必要。<br>整个搭建博客的过程其实还是遇见了不少麻烦，包括在我尝试发这第一篇博客的时候也是。但是时间跨度太大了，或许等以后博客用熟悉了可以写一篇博客的<del>食用</del>指南。一开始以为会有蛮多想说的，但是写出来又只有这么一点东西了，那么还是直接开始我对这学年的总结一类的内容吧。毕竟标题是close &amp; begin。</p><h2 id="学年总结"><a href="#学年总结" class="headerlink" title="学年总结"></a>学年总结</h2><p>主要是分为两个部分吧，一个是我总结一下我获得的成绩或者我做出过的努力，另一个是我的反思或者说是对未来的走向的期望。</p><h3 id="专业成绩（计科）"><a href="#专业成绩（计科）" class="headerlink" title="专业成绩（计科）"></a>专业成绩（计科）</h3><p>按照学校的规划或者是人培计划学了以下课程：计算机科学导论，c语言，web设计，高等数学（庆幸都过了，成绩也还将就），数据结构and so on。<br>自学的内容有浅显一点的python的用法和一些零碎的技能。<br>陪跑的比赛太多了就不一一列举了，写两个意思一下：山城杯，大英赛 and so on。</p><h3 id="爱好成绩（辩论）"><a href="#爱好成绩（辩论）" class="headerlink" title="爱好成绩（辩论）"></a>爱好成绩（辩论）</h3><p>概述一下我一年的收获吧。院赛因为疫情没办完，也就不提院赛的成绩了。在下半年的校赛中，智能院拿了善思杯的冠军，我个人是善思杯的佳辩榜第二。在学期末接手了我们院队的队长和校队的副队。</p><h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><p>在专业课上基本是达到了我们学校的中上游水平，但是这远远不够，在下半学年开学的时候就在学的python却一直到军训才差不多学完基础，各种借口导致太拖拉了。在网安方面更是因为诸多的理由没有什么实质性的学习进展，在这个暑假至少要先学会linux的基本运用和汇编语言，并开始学习pwn，顺便给python和数据结构再收个尾。<br>辩论倒是做得还不错，在这个暑假把报名的那几场比赛打好应该就能更进步一点了。不过因为辩论确实也是一件费时间的事情，但是我又舍不得削减辩论只能在之后削减一下其他的娱乐时间，不过辩论对我也算娱乐就是了。既然接下了队长下学期要好好干才行呢。</p>]]></content>
    
    
    <summary type="html">&lt;pre&gt;&lt;code&gt;关于终于开始用这个早就配置的差不多的博客，结果搞崩又重新配置这件事。
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    
    <category term="life" scheme="http://librariany.cn/tags/life/"/>
    
  </entry>
  
</feed>
