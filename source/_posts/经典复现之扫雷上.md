---
title: 经典复现之扫雷
categories:
  - 逆向自学之路
date: 2023-09-28 19:29:40
tags:
---

上半部分为找到扫雷的地图，也就是炸弹信息的存储地。
<!-- more -->
## xdbg查找
### 定位查找的函数
扫雷的游戏界面是一个二维的矩阵，而在某个地方显示图像会需要用到beginpaint并且以endpaint结束。所以尝试去定位此。而猜测扫雷界面一次性显示，使用了双缓存技术，所以可以尝试去定位bitblt。
beginpaint：为指定窗口做传输信息的准备，向系统提交显示图像的申请，在beginpaint返回携带显示资源句柄，可以调用函数进行图像显示。
endpaint：作为传输结束的标志，因为beginpaint后该显示卡处于独占的状态，需要以此为标志进行释放。
双缓存：也就是先在内存准备好需要展示的内容，而后一次性读取显示。
bitblt：位块传输，也就是从源头地点中将一个矩形区的图像转到目标地点中同样大小的矩形区。语法为`BitBlt (hdcDst, xDst, yDst, cx, cy, hdcSrc, xSrc, ySrc, dwROP) ;`
### 查找过程
首先是找到这几个的所在地，打断点观察。
![](./经典复现之扫雷上/1.1.png)
![](./经典复现之扫雷上/1.2.png)
![](./经典复现之扫雷上/1.4.png)
![](./经典复现之扫雷上/1.3.png)
![](./经典复现之扫雷上/1.5.png)
在xdbg中debug，因为断点打在了显示图像的函数上所以一开始窗口显示不出来，执行第三次bitblt才会显示出出窗口。且鼠标移到上面是缓存图标无法点击移动。
![](./经典复现之扫雷上/1.7.png)
运行以后会出现一个基础的页面，在begin运行后出现了计时和计数，可以发现这一部分和扫雷地图是分开加载的。
![](./经典复现之扫雷上/1.8.png)
![](./经典复现之扫雷上/1.9.png)
而继续运行bitblt发现出现了一个扫雷的格子，已经开始加载地图了。
![](./经典复现之扫雷上/1.10.png)
然后经过单步运行后发现了是在call 后续的bitblt后出现的这个格子，且在此之前入栈了9个未知量。猜测需要的信息就在被入栈的地址中。所以转向去看段地址ebx的内容。
![](./经典复现之扫雷上/1.11.png)
在ebx的内容中给可以看见of，8f，10因为ebx缪按存储的段地址指向的10，后续出现也具有规律，推测是每行的边距。0f个数比较多推测是空白地方，8f是炸弹。而在上面还有一行，63刚好对应99个炸弹数目，1e，10是长宽，后续有待验证。这时虽然没有显示完但是该有的数据都有了，所以可以确定是双缓存。
![](./经典复现之扫雷上/1.12.png)
在全部加载完成后再执行endpaint，而后扫雷界面正常显示，不再出现缓存图标。
![](./经典复现之扫雷上/1.13.png)
点击其中一个方块以后，立刻转到bitblt对界面进行修改，且在尚未显示出来的时候内存中的数字已经发生变化。
![](./经典复现之扫雷上/1.14.png)
![](./经典复现之扫雷上/1.16.png)
而后在进行单步执行，该处变为41，再执行后扫雷该地区显示出1。而8f地区再点击后也经过过程变成地雷，对于数字的猜测实现。
![](./经典复现之扫雷上/1.17.png)
![](./经典复现之扫雷上/1.18.png)
![](./经典复现之扫雷上/1.19.png)
![](./经典复现之扫雷上/1.20.png)
接下来又开一局对41这个数字进行猜测，在内存显示为42的在图中显示为2.可以认为40为初始值，计算出附近雷的数量后改变内存的值来索引需要显示出的数字的素材。
![](./经典复现之扫雷上/1.21.png)
至此对扫雷的分析差不多结束了。
## CE分析扫雷
### 找到可疑的内存地址并分析其内存
先导入运行中的扫雷程序，并进行初始扫描。
![](./经典复现之扫雷上/2.1.png)
初始扫描后，点击某一个方块，不是雷就扫描变化的，是就扫描不变的，最后锁定到一个地址。目标其实就是找地图所在的区域，变化或者不变化在不同的情况下都有可能在地图中出现，选择其一是为了更简单的找到其所在地。
![](./经典复现之扫雷上/2.2.png)
![](./经典复现之扫雷上/2.3.png)
![](./经典复现之扫雷上/2.4.png)
![](./经典复现之扫雷上/2.5.png)
转向最后一个地址的内存查看，可以发现和xdbg找到的内存是一样的。
![](./经典复现之扫雷上/2.6.png)